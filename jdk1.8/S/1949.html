<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>src/java/nio/file/Path.java</title>
<meta name="robots" content="noindex,nofollow">
<meta name="generator" content="GLOBAL-6.6.3">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
<a id="TOP" name="TOP"></a><div class="comment">
/* [&lt;][&gt;]<a href="#L106">[^]</a><a href="#L800">[v]</a>[top]<a href="#BOTTOM">[bottom]</a><a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
<hr>
<h2 class="header">DEFINITIONS</h2>
This source file includes following definitions.
<ol>
<li><a href="#L106" title="Defined at 106.">getFileSystem</a></li>
<li><a href="#L116" title="Defined at 116.">isAbsolute</a></li>
<li><a href="#L125" title="Defined at 125.">getRoot</a></li>
<li><a href="#L135" title="Defined at 135.">getFileName</a></li>
<li><a href="#L160" title="Defined at 160.">getParent</a></li>
<li><a href="#L168" title="Defined at 168.">getNameCount</a></li>
<li><a href="#L188" title="Defined at 188.">getName</a></li>
<li><a href="#L215" title="Defined at 215.">subpath</a></li>
<li><a href="#L240" title="Defined at 240.">startsWith</a></li>
<li><a href="#L258" title="Defined at 258.">startsWith</a></li>
<li><a href="#L285" title="Defined at 285.">endsWith</a></li>
<li><a href="#L306" title="Defined at 306.">endsWith</a></li>
<li><a href="#L333" title="Defined at 333.">normalize</a></li>
<li><a href="#L358" title="Defined at 358.">resolve</a></li>
<li><a href="#L378" title="Defined at 378.">resolve</a></li>
<li><a href="#L399" title="Defined at 399.">resolveSibling</a></li>
<li><a href="#L416" title="Defined at 416.">resolveSibling</a></li>
<li><a href="#L458" title="Defined at 458.">relativize</a></li>
<li><a href="#L511" title="Defined at 511.">toUri</a></li>
<li><a href="#L534" title="Defined at 534.">toAbsolutePath</a></li>
<li><a href="#L580" title="Defined at 580.">toRealPath</a></li>
<li><a href="#L598" title="Defined at 598.">toFile</a></li>
<li><a href="#L661" title="Defined at 661.">register</a></li>
<li><a href="#L709" title="Defined at 709.">register</a></li>
<li><a href="#L727" title="Defined at 727.">iterator</a></li>
<li><a href="#L751" title="Defined at 751.">compareTo</a></li>
<li><a href="#L775" title="Defined at 775.">equals</a></li>
<li><a href="#L786" title="Defined at 786.">hashCode</a></li>
<li><a href="#L800" title="Defined at 800.">toString</a></li>
</ol>
<hr>
<pre>
<div class="comment">
  Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</div>
<a id="L25" name="L25"></a>  25 
<a id="L26" name="L26"></a>  26 <strong class="reserved">package</strong> <a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.nio.<a href="../D/16022.html" title="Multiple defined in 3 places.">file</a>;
<a id="L27" name="L27"></a>  27 
<a id="L28" name="L28"></a>  28 <strong class="reserved">import</strong> java.io.File;
<a id="L29" name="L29"></a>  29 <strong class="reserved">import</strong> java.io.IOException;
<a id="L30" name="L30"></a>  30 <strong class="reserved">import</strong> java.net.URI;
<a id="L31" name="L31"></a>  31 <strong class="reserved">import</strong> java.util.Iterator;
<a id="L32" name="L32"></a>  32 
<div class="comment">
  An object that may be used to locate a file in a file system. It will
  typically represent a system dependent file path.
  <p> A <code>Path</code> represents a path that is hierarchical and composed of a
  sequence of directory and file name elements separated by a special separator
  or delimiter. A <em>root component</em>, that identifies a file system
  hierarchy, may also be present. The name element that is <em>farthest</em>
  from the root of the directory hierarchy is the name of a file or directory.
  The other name elements are directory names. A <code>Path</code> can represent a
  root, a root and a sequence of names, or simply one or more name elements.
  A <code>Path</code> is considered to be an <i>empty path</i> if it consists
  solely of one name element that is empty. Accessing a file using an
  <i>empty path</i> is equivalent to accessing the default directory of the
  file system. <code>Path</code> defines the {@link #getFileName() getFileName},
  {@link #getParent getParent}, {@link #getRoot getRoot}, and {@link #subpath
  subpath} methods to access the path components or a subsequence of its name
  elements.
  </p><p> In addition to accessing the components of a path, a <code>Path</code> also
  defines the {@link #resolve(Path) resolve} and {@link #resolveSibling(Path)
  resolveSibling} methods to combine paths. The {@link #relativize relativize}
  method that can be used to construct a relative path between two paths.
  Paths can be {@link #compareTo compared}, and tested against each other using
  the {@link #startsWith startsWith} and {@link #endsWith endsWith} methods.
  </p><p> This interface extends {@link Watchable} interface so that a directory
  located by a path can be {@link #register registered} with a {@link
  WatchService} and entries in the directory watched. </p>
  <p> <b>WARNING:</b> This interface is only intended to be implemented by
  those developing custom file system implementations. Methods may be added to
  this interface in future releases. </p>
  <h2>Accessing Files</h2>
  <p> Paths may be used with the {@link Files} class to operate on files,
  directories, and other types of files. For example, suppose we want a {@link
  java.io.BufferedReader} to read text from a file "<code>access.log</code>". The
  file is located in a directory "<code>logs</code>" relative to the current working
  directory and is UTF-8 encoded.
  </p><pre>      Path path = FileSystems.getDefault().getPath("logs", "access.log");
      BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);
  </pre>
  <a name="interop"></a><h2>Interoperability</h2>
  <p> Paths associated with the default {@link
  java.nio.file.spi.FileSystemProvider provider} are generally interoperable
  with the {@link java.io.File java.io.File} class. Paths created by other
  providers are unlikely to be interoperable with the abstract path names
  represented by <code>java.io.File</code>. The {@link java.io.File#toPath toPath}
  method may be used to obtain a <code>Path</code> from the abstract path name
  represented by a <code>java.io.File</code> object. The resulting <code>Path</code> can
  be used to operate on the same file as the <code>java.io.File</code> object. In
  addition, the {@link #toFile toFile} method is useful to construct a {@code
  File} from the <code>String</code> representation of a <code>Path</code>.
  </p><h2>Concurrency</h2>
  <p> Implementations of this interface are immutable and safe for use by
  multiple concurrent threads.
  @since 1.7
  @see Paths</p></div>
<a id="L97" name="L97"></a>  97 
<a id="L98" name="L98"></a>  98 <strong class="reserved">public</strong> <strong class="reserved">interface</strong> <a href="../R/6071.html" title="Multiple referred from 195 places.">Path</a>
<a id="L99" name="L99"></a>  99     <strong class="reserved">extends</strong> <a href="../S/1704.html#L96" title="Defined at 96 in src/java/lang/Comparable.java.">Comparable</a>&lt;<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a>&gt;, <a href="../S/1577.html#L45" title="Defined at 45 in src/java/lang/Iterable.java.">Iterable</a>&lt;<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a>&gt;, <a href="../S/1878.html#L45" title="Defined at 45 in src/java/nio/file/Watchable.java.">Watchable</a>
<a id="L100" name="L100"></a> 100 <em class="brace">{</em>
<div class="comment">
      Returns the file system that created this object.
      @return  the file system that created this object</div>
<a id="L106" name="L106"></a> 106     <a href="../D/3214.html" title="Multiple defined in 2 places.">FileSystem</a> <a href="../R/16585.html" title="Multiple referred from 9 places.">getFileSystem</a>();
<a id="L107" name="L107"></a> 107 
<div class="comment">
      Tells whether or not this path is absolute.
      <p> An absolute path is complete in that it doesn't need to be combined
      with other path information in order to locate a file.
      @return  <code>true</code> if, and only if, this path is absolute</p></div>
<a id="L116" name="L116"></a> 116     <strong class="reserved">boolean</strong> <a href="../R/21122.html" title="Multiple referred from 26 places.">isAbsolute</a>();
<a id="L117" name="L117"></a> 117 
<div class="comment">
      Returns the root component of this path as a <code>Path</code> object,
      or <code>null</code> if this path does not have a root component.
      @return  a path representing the root component of this path,
               or <code>null</code></div>
<a id="L125" name="L125"></a> 125     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/18758.html" title="Multiple referred from 54 places.">getRoot</a>();
<a id="L126" name="L126"></a> 126 
<div class="comment">
      Returns the name of the file or directory denoted by this path as a
      <code>Path</code> object. The file name is the <em>farthest</em> element from
      the root in the directory hierarchy.
      @return  a path representing the name of the file or directory, or
               <code>null</code> if this path has zero elements</div>
<a id="L135" name="L135"></a> 135     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/16578.html" title="Multiple referred from 15 places.">getFileName</a>();
<a id="L136" name="L136"></a> 136 
<div class="comment">
      Returns the <em>parent path</em>, or <code>null</code> if this path does not
      have a parent.
      <p> The parent of this path object consists of this path's root
      component, if any, and each element in the path except for the
      <em>farthest</em> from the root in the directory hierarchy. This method
      does not access the file system; the path or its parent may not exist.
      Furthermore, this method does not eliminate special names such as "."
      and ".." that may be used in some implementations. On UNIX for example,
      the parent of "<code>/a/b/c</code>" is "<code>/a/b</code>", and the parent of
      <code>"x/y/.</code>" is "<code>x/y</code>". This method may be used with the {@link
      #normalize normalize} method, to eliminate redundant names, for cases where
      <em>shell-like</em> navigation is required.
      </p><p> If this path has one or more elements, and no root component, then
      this method is equivalent to evaluating the expression:
      </p><blockquote><pre>      subpath(0,&nbsp;getNameCount()-1);
      </pre></blockquote>
      @return  a path representing the path's parent</div>
<a id="L160" name="L160"></a> 160     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/18269.html" title="Multiple referred from 606 places.">getParent</a>();
<a id="L161" name="L161"></a> 161 
<div class="comment">
      Returns the number of name elements in the path.
      @return  the number of elements in the path, or <code>0</code> if this path
               only represents a root component</div>
<a id="L168" name="L168"></a> 168     <strong class="reserved">int</strong> getNameCount();
<a id="L169" name="L169"></a> 169 
<div class="comment">
      Returns a name element of this path as a <code>Path</code> object.
      <p> The <code>index</code> parameter is the index of the name element to return.
      The element that is <em>closest</em> to the root in the directory hierarchy
      has index <code>0</code>. The element that is <em>farthest</em> from the root
      has index {@link #getNameCount count}<code>-1</code>.
      @param   index
               the index of the element
      @return  the name element
      @throws  IllegalArgumentException
               if <code>index</code> is negative, <code>index</code> is greater than or
               equal to the number of elements, or this path has zero name
               elements</p></div>
<a id="L188" name="L188"></a> 188     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/17826.html" title="Multiple referred from 2652 places.">getName</a>(<strong class="reserved">int</strong> <a href="../D/24461.html" title="Multiple defined in 6 places.">index</a>);
<a id="L189" name="L189"></a> 189 
<div class="comment">
      Returns a relative <code>Path</code> that is a subsequence of the name
      elements of this path.
      <p> The <code>beginIndex</code> and <code>endIndex</code> parameters specify the
      subsequence of name elements. The name that is <em>closest</em> to the root
      in the directory hierarchy has index <code>0</code>. The name that is
      <em>farthest</em> from the root has index {@link #getNameCount
      count}<code>-1</code>. The returned <code>Path</code> object has the name elements
      that begin at <code>beginIndex</code> and extend to the element at index {@code
      endIndex-1}.
      @param   beginIndex
               the index of the first element, inclusive
      @param   endIndex
               the index of the last element, exclusive
      @return  a new <code>Path</code> object that is a subsequence of the name
               elements in this <code>Path</code>
      @throws  IllegalArgumentException
               if <code>beginIndex</code> is negative, or greater than or equal to
               the number of elements. If <code>endIndex</code> is less than or
               equal to <code>beginIndex</code>, or larger than the number of elements.</p></div>
<a id="L215" name="L215"></a> 215     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> subpath(<strong class="reserved">int</strong> beginIndex, <strong class="reserved">int</strong> endIndex);
<a id="L216" name="L216"></a> 216 
<div class="comment">
      Tests if this path starts with the given path.
      <p> This path <em>starts</em> with the given path if this path's root
      component <em>starts</em> with the root component of the given path,
      and this path starts with the same name elements as the given path.
      If the given path has more name elements than this path then <code>false</code>
      is returned.
      </p><p> Whether or not the root component of this path starts with the root
      component of the given path is file system specific. If this path does
      not have a root component and the given path has a root component then
      this path does not start with the given path.
      </p><p> If the given path is associated with a different <code>FileSystem</code>
      to this path then <code>false</code> is returned.
      @param   other
               the given path
      @return  <code>true</code> if this path starts with the given path; otherwise
               <code>false</code></p></div>
<a id="L240" name="L240"></a> 240     <strong class="reserved">boolean</strong> <a href="../R/28868.html" title="Multiple referred from 490 places.">startsWith</a>(<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> other);
<a id="L241" name="L241"></a> 241 
<div class="comment">
      Tests if this path starts with a <code>Path</code>, constructed by converting
      the given path string, in exactly the manner specified by the {@link
      #startsWith(Path) startsWith(Path)} method. On UNIX for example, the path
      "<code>foo/bar</code>" starts with "<code>foo</code>" and "<code>foo/bar</code>". It
      does not start with "<code>f</code>" or "<code>fo</code>".
      @param   other
               the given path string
      @return  <code>true</code> if this path starts with the given path; otherwise
               <code>false</code>
      @throws  InvalidPathException
               If the path string cannot be converted to a Path.</div>
<a id="L258" name="L258"></a> 258     <strong class="reserved">boolean</strong> <a href="../R/28868.html" title="Multiple referred from 490 places.">startsWith</a>(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> other);
<a id="L259" name="L259"></a> 259 
<div class="comment">
      Tests if this path ends with the given path.
      <p> If the given path has <em>N</em> elements, and no root component,
      and this path has <em>N</em> or more elements, then this path ends with
      the given path if the last <em>N</em> elements of each path, starting at
      the element farthest from the root, are equal.
      </p><p> If the given path has a root component then this path ends with the
      given path if the root component of this path <em>ends with</em> the root
      component of the given path, and the corresponding elements of both paths
      are equal. Whether or not the root component of this path ends with the
      root component of the given path is file system specific. If this path
      does not have a root component and the given path has a root component
      then this path does not end with the given path.
      </p><p> If the given path is associated with a different <code>FileSystem</code>
      to this path then <code>false</code> is returned.
      @param   other
               the given path
      @return  <code>true</code> if this path ends with the given path; otherwise
               <code>false</code></p></div>
<a id="L285" name="L285"></a> 285     <strong class="reserved">boolean</strong> <a href="../R/13806.html" title="Multiple referred from 248 places.">endsWith</a>(<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> other);
<a id="L286" name="L286"></a> 286 
<div class="comment">
      Tests if this path ends with a <code>Path</code>, constructed by converting
      the given path string, in exactly the manner specified by the {@link
      #endsWith(Path) endsWith(Path)} method. On UNIX for example, the path
      "<code>foo/bar</code>" ends with "<code>foo/bar</code>" and "<code>bar</code>". It does
      not end with "<code>r</code>" or "<code>/bar</code>". Note that trailing separators
      are not taken into account, and so invoking this method on the {@code
      Path}"<code>foo/bar</code>" with the <code>String</code> "<code>bar/</code>" returns
      <code>true</code>.
      @param   other
               the given path string
      @return  <code>true</code> if this path ends with the given path; otherwise
               <code>false</code>
      @throws  InvalidPathException
               If the path string cannot be converted to a Path.</div>
<a id="L306" name="L306"></a> 306     <strong class="reserved">boolean</strong> <a href="../R/13806.html" title="Multiple referred from 248 places.">endsWith</a>(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> other);
<a id="L307" name="L307"></a> 307 
<div class="comment">
      Returns a path that is this path with redundant name elements eliminated.
      <p> The precise definition of this method is implementation dependent but
      in general it derives from this path, a path that does not contain
      <em>redundant</em> name elements. In many file systems, the "<code>.</code>"
      and "<code>..</code>" are special names used to indicate the current directory
      and parent directory. In such file systems all occurrences of "<code>.</code>"
      are considered redundant. If a "<code>..</code>" is preceded by a
      non-"<code>..</code>" name then both names are considered redundant (the
      process to identify such names is repeated until it is no longer
      applicable).
      </p><p> This method does not access the file system; the path may not locate
      a file that exists. Eliminating "<code>..</code>" and a preceding name from a
      path may result in the path that locates a different file than the original
      path. This can arise when the preceding name is a symbolic link.
      @return  the resulting path or this path if it does not contain
               redundant name elements; an empty path is returned if this path
               does have a root component and all name elements are redundant
      @see #getParent
      @see #toRealPath</p></div>
<a id="L333" name="L333"></a> 333     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/23781.html" title="Multiple referred from 143 places.">normalize</a>();
<a id="L334" name="L334"></a> 334 
<a id="L335" name="L335"></a> 335     <em class="comment">// -- resolution and relativization --</em>
<a id="L336" name="L336"></a> 336 
<div class="comment">
      Resolve the given path against this path.
      <p> If the <code>other</code> parameter is an {@link #isAbsolute() absolute}
      path then this method trivially returns <code>other</code>. If <code>other</code>
      is an <i>empty path</i> then this method trivially returns this path.
      Otherwise this method considers this path to be a directory and resolves
      the given path against this path. In the simplest case, the given path
      does not have a {@link #getRoot root} component, in which case this method
      <em>joins</em> the given path to this path and returns a resulting path
      that {@link #endsWith ends} with the given path. Where the given path has
      a root component then resolution is highly implementation dependent and
      therefore unspecified.
      @param   other
               the path to resolve against this path
      @return  the resulting path
      @see #relativize</p></div>
<a id="L358" name="L358"></a> 358     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/26316.html" title="Multiple referred from 78 places.">resolve</a>(<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> other);
<a id="L359" name="L359"></a> 359 
<div class="comment">
      Converts a given path string to a <code>Path</code> and resolves it against
      this <code>Path</code> in exactly the manner specified by the {@link
      #resolve(Path) resolve} method. For example, suppose that the name
      separator is "<code>/</code>" and a path represents "<code>foo/bar</code>", then
      invoking this method with the path string "<code>gus</code>" will result in
      the <code>Path</code> "<code>foo/bar/gus</code>".
      @param   other
               the path string to resolve against this path
      @return  the resulting path
      @throws  InvalidPathException
               if the path string cannot be converted to a Path.
      @see FileSystem#getPath</div>
<a id="L378" name="L378"></a> 378     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/26316.html" title="Multiple referred from 78 places.">resolve</a>(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> other);
<a id="L379" name="L379"></a> 379 
<div class="comment">
      Resolves the given path against this path's {@link #getParent parent}
      path. This is useful where a file name needs to be <i>replaced</i> with
      another file name. For example, suppose that the name separator is
      "<code>/</code>" and a path represents "<code>dir1/dir2/foo</code>", then invoking
      this method with the <code>Path</code> "<code>bar</code>" will result in the {@code
      Path} "<code>dir1/dir2/bar</code>". If this path does not have a parent path,
      or <code>other</code> is {@link #isAbsolute() absolute}, then this method
      returns <code>other</code>. If <code>other</code> is an empty path then this method
      returns this path's parent, or where this path doesn't have a parent, the
      empty path.
      @param   other
               the path to resolve against this path's parent
      @return  the resulting path
      @see #resolve(Path)</div>
<a id="L399" name="L399"></a> 399     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> resolveSibling(<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> other);
<a id="L400" name="L400"></a> 400 
<div class="comment">
      Converts a given path string to a <code>Path</code> and resolves it against
      this path's {@link #getParent parent} path in exactly the manner
      specified by the {@link #resolveSibling(Path) resolveSibling} method.
      @param   other
               the path string to resolve against this path's parent
      @return  the resulting path
      @throws  InvalidPathException
               if the path string cannot be converted to a Path.
      @see FileSystem#getPath</div>
<a id="L416" name="L416"></a> 416     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> resolveSibling(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> other);
<a id="L417" name="L417"></a> 417 
<div class="comment">
      Constructs a relative path between this path and a given path.
      <p> Relativization is the inverse of {@link #resolve(Path) resolution}.
      This method attempts to construct a {@link #isAbsolute relative} path
      that when {@link #resolve(Path) resolved} against this path, yields a
      path that locates the same file as the given path. For example, on UNIX,
      if this path is <code>"/a/b"</code> and the given path is <code>"/a/b/c/d"</code>
      then the resulting relative path would be <code>"c/d"</code>. Where this
      path and the given path do not have a {@link #getRoot root} component,
      then a relative path can be constructed. A relative path cannot be
      constructed if only one of the paths have a root component. Where both
      paths have a root component then it is implementation dependent if a
      relative path can be constructed. If this path and the given path are
      {@link #equals equal} then an <i>empty path</i> is returned.
      </p><p> For any two {@link #normalize normalized} paths <i>p</i> and
      <i>q</i>, where <i>q</i> does not have a root component,
      </p><blockquote>
        <i>p</i><tt>.relativize(</tt><i>p</i><tt>.resolve(</tt><i>q</i><tt>)).equals(</tt><i>q</i><tt>)</tt>
      </blockquote>
      <p> When symbolic links are supported, then whether the resulting path,
      when resolved against this path, yields a path that can be used to locate
      the {@link Files#isSameFile same} file as <code>other</code> is implementation
      dependent. For example, if this path is  <code>"/a/b"</code> and the given
      path is <code>"/a/x"</code> then the resulting relative path may be {@code
      "../x"}. If <code>"b"</code> is a symbolic link then is implementation
      dependent if <code>"a/b/../x"</code> would locate the same file as <code>"/a/x"</code>.
      @param   other
               the path to relativize against this path
      @return  the resulting relative path, or an empty path if both paths are
               equal
      @throws  IllegalArgumentException
               if <code>other</code> is not a <code>Path</code> that can be relativized
               against this path</p></div>
<a id="L458" name="L458"></a> 458     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/25845.html" title="Multiple referred from 2 places.">relativize</a>(<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> other);
<a id="L459" name="L459"></a> 459 
<div class="comment">
      Returns a URI to represent this path.
      <p> This method constructs an absolute {@link URI} with a {@link
      URI#getScheme() scheme} equal to the URI scheme that identifies the
      provider. The exact form of the scheme specific part is highly provider
      dependent.
      </p><p> In the case of the default provider, the URI is hierarchical with
      a {@link URI#getPath() path} component that is absolute. The query and
      fragment components are undefined. Whether the authority component is
      defined or not is implementation dependent. There is no guarantee that
      the <code>URI</code> may be used to construct a {@link java.io.File java.io.File}.
      In particular, if this path represents a Universal Naming Convention (UNC)
      path, then the UNC server name may be encoded in the authority component
      of the resulting URI. In the case of the default provider, and the file
      exists, and it can be determined that the file is a directory, then the
      resulting <code>URI</code> will end with a slash.
      </p><p> The default provider provides a similar <em>round-trip</em> guarantee
      to the {@link java.io.File} class. For a given <code>Path</code> <i>p</i> it
      is guaranteed that
      </p><blockquote><tt>
      {@link Paths#get(URI) Paths.get}(</tt><i>p</i><tt>.toUri()).equals(</tt><i>p</i>
      <tt>.{@link #toAbsolutePath() toAbsolutePath}())</tt>
      </blockquote>
      so long as the original <code>Path</code>, the <code>URI</code>, and the new {@code
      Path} are all created in (possibly different invocations of) the same
      Java virtual machine. Whether other providers make any guarantees is
      provider specific and therefore unspecified.
      <p> When a file system is constructed to access the contents of a file
      as a file system then it is highly implementation specific if the returned
      URI represents the given path in the file system or it represents a
      <em>compound</em> URI that encodes the URI of the enclosing file system.
      A format for compound URIs is not defined in this release; such a scheme
      may be added in a future release.
      @return  the URI representing this path
      @throws  java.io.IOError
               if an I/O error occurs obtaining the absolute path, or where a
               file system is constructed to access the contents of a file as
               a file system, and the URI of the enclosing file system cannot be
               obtained
      @throws  SecurityException
               In the case of the default provider, and a security manager
               is installed, the {@link #toAbsolutePath toAbsolutePath} method
               throws a security exception.</p></div>
<a id="L511" name="L511"></a> 511     <a href="../D/9247.html" title="Multiple defined in 4 places.">URI</a> <a href="../R/29362.html" title="Multiple referred from 5 places.">toUri</a>();
<a id="L512" name="L512"></a> 512 
<div class="comment">
      Returns a <code>Path</code> object representing the absolute path of this
      path.
      <p> If this path is already {@link Path#isAbsolute absolute} then this
      method simply returns this path. Otherwise, this method resolves the path
      in an implementation dependent manner, typically by resolving the path
      against a file system default directory. Depending on the implementation,
      this method may throw an I/O error if the file system is not accessible.
      @return  a <code>Path</code> object representing the absolute path
      @throws  java.io.IOError
               if an I/O error occurs
      @throws  SecurityException
               In the case of the default provider, a security manager
               is installed, and this path is not absolute, then the security
               manager's {@link SecurityManager#checkPropertyAccess(String)
               checkPropertyAccess} method is invoked to check access to the
               system property <code>user.dir</code></p></div>
<a id="L534" name="L534"></a> 534     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> <a href="../R/29212.html" title="Multiple referred from 2 places.">toAbsolutePath</a>();
<a id="L535" name="L535"></a> 535 
<div class="comment">
      Returns the <em>real</em> path of an existing file.
      <p> The precise definition of this method is implementation dependent but
      in general it derives from this path, an {@link #isAbsolute absolute}
      path that locates the {@link Files#isSameFile same} file as this path, but
      with name elements that represent the actual name of the directories
      and the file. For example, where filename comparisons on a file system
      are case insensitive then the name elements represent the names in their
      actual case. Additionally, the resulting path has redundant name
      elements removed.
      </p><p> If this path is relative then its absolute path is first obtained,
      as if by invoking the {@link #toAbsolutePath toAbsolutePath} method.
      </p><p> The <code>options</code> array may be used to indicate how symbolic links
      are handled. By default, symbolic links are resolved to their final
      target. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is
      present then this method does not resolve symbolic links.
      Some implementations allow special names such as "<code>..</code>" to refer to
      the parent directory. When deriving the <em>real path</em>, and a
      "<code>..</code>" (or equivalent) is preceded by a non-"<code>..</code>" name then
      an implementation will typically cause both names to be removed. When
      not resolving symbolic links and the preceding name is a symbolic link
      then the names are only removed if it guaranteed that the resulting path
      will locate the same file as this path.
      @param   options
               options indicating how symbolic links are handled
      @return  an absolute path represent the <em>real</em> path of the file
               located by this object
      @throws  IOException
               if the file does not exist or an I/O error occurs
      @throws  SecurityException
               In the case of the default provider, and a security manager
               is installed, its {@link SecurityManager#checkRead(String) checkRead}
               method is invoked to check read access to the file, and where
               this path is not absolute, its {@link SecurityManager#checkPropertyAccess(String)
               checkPropertyAccess} method is invoked to check access to the
               system property <code>user.dir</code></p></div>
<a id="L580" name="L580"></a> 580     <a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> toRealPath(<a href="../S/1874.html#L34" title="Defined at 34 in src/java/nio/file/LinkOption.java.">LinkOption</a>... <a href="../S/7709.html#L57" title="Defined at 57 in src/com/sun/javadoc/RootDoc.java.">options</a>) <strong class="reserved">throws</strong> <a href="../S/1392.html#L39" title="Defined at 39 in src/java/io/IOException.java.">IOException</a>;
<a id="L581" name="L581"></a> 581 
<div class="comment">
      Returns a {@link File} object representing this path. Where this {@code
      Path} is associated with the default provider, then this method is
      equivalent to returning a <code>File</code> object constructed with the
      <code>String</code> representation of this path.
      <p> If this path was created by invoking the <code>File</code> {@link
      File#toPath toPath} method then there is no guarantee that the {@code
      File} object returned by this method is {@link #equals equal} to the
      original <code>File</code>.
      @return  a <code>File</code> object representing this path
      @throws  UnsupportedOperationException
               if this <code>Path</code> is not associated with the default provider</p></div>
<a id="L598" name="L598"></a> 598     <a href="../S/1433.html#L149" title="Defined at 149 in src/java/io/File.java.">File</a> <a href="../R/29256.html" title="Multiple referred from 7 places.">toFile</a>();
<a id="L599" name="L599"></a> 599 
<a id="L600" name="L600"></a> 600     <em class="comment">// -- watchable --</em>
<a id="L601" name="L601"></a> 601 
<div class="comment">
      Registers the file located by this path with a watch service.
      <p> In this release, this path locates a directory that exists. The
      directory is registered with the watch service so that entries in the
      directory can be watched. The <code>events</code> parameter is the events to
      register and may contain the following events:
      </p><ul><li>{@link StandardWatchEventKinds#ENTRY_CREATE ENTRY_CREATE} -
            entry created or moved into the directory</li><li>{@link StandardWatchEventKinds#ENTRY_DELETE ENTRY_DELETE} -
             entry deleted or moved out of the directory</li><li>{@link StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} -
             entry in directory was modified</li>
      </ul>
      <p> The {@link WatchEvent#context context} for these events is the
      relative path between the directory located by this path, and the path
      that locates the directory entry that is created, deleted, or modified.
      </p><p> The set of events may include additional implementation specific
      event that are not defined by the enum {@link StandardWatchEventKinds}
      </p><p> The <code>modifiers</code> parameter specifies <em>modifiers</em> that
      qualify how the directory is registered. This release does not define any
      <em>standard</em> modifiers. It may contain implementation specific
      modifiers.
      </p><p> Where a file is registered with a watch service by means of a symbolic
      link then it is implementation specific if the watch continues to depend
      on the existence of the symbolic link after it is registered.
      @param   watcher
               the watch service to which this object is to be registered
      @param   events
               the events for which this object should be registered
      @param   modifiers
               the modifiers, if any, that modify how the object is registered
      @return  a key representing the registration of this object with the
               given watch service
      @throws  UnsupportedOperationException
               if unsupported events or modifiers are specified
      @throws  IllegalArgumentException
               if an invalid combination of events or modifiers is specified
      @throws  ClosedWatchServiceException
               if the watch service is closed
      @throws  NotDirectoryException
               if the file is registered to watch the entries in a directory
               and the file is not a directory  <i>(optional specific exception)</i>
      @throws  IOException
               if an I/O error occurs
      @throws  SecurityException
               In the case of the default provider, and a security manager is
               installed, the {@link SecurityManager#checkRead(String) checkRead}
               method is invoked to check read access to the file.</p></div>
<a id="L660" name="L660"></a> 660     @<a href="../S/1740.html#L51" title="Defined at 51 in src/java/lang/Override.java.">Override</a>
<a id="L661" name="L661"></a> 661     <a href="../S/1934.html#L84" title="Defined at 84 in src/java/nio/file/WatchKey.java.">WatchKey</a> <a href="../R/25749.html" title="Multiple referred from 136 places.">register</a>(<a href="../S/1912.html#L106" title="Defined at 106 in src/java/nio/file/WatchService.java.">WatchService</a> watcher,
<a id="L662" name="L662"></a> 662                       <a href="../S/1916.html#L47" title="Defined at 47 in src/java/nio/file/WatchEvent.java.">WatchEvent</a>.<a href="../D/4856.html" title="Multiple defined in 7 places.">Kind</a>&lt;?&gt;[] events,
<a id="L663" name="L663"></a> 663                       <a href="../S/1916.html#L47" title="Defined at 47 in src/java/nio/file/WatchEvent.java.">WatchEvent</a>.<a href="../D/5688.html" title="Multiple defined in 3 places.">Modifier</a>... <a href="../S/7693.html#L86" title="Defined at 86 in src/com/sun/javadoc/ProgramElementDoc.java.">modifiers</a>)
<a id="L664" name="L664"></a> 664         <strong class="reserved">throws</strong> <a href="../S/1392.html#L39" title="Defined at 39 in src/java/io/IOException.java.">IOException</a>;
<a id="L665" name="L665"></a> 665 
<div class="comment">
      Registers the file located by this path with a watch service.
      <p> An invocation of this method behaves in exactly the same way as the
      invocation
      </p><pre>          watchable.{@link #register(WatchService,WatchEvent.Kind[],WatchEvent.Modifier[]) register}(watcher, events, new WatchEvent.Modifier[0]);
      </pre>
      <p> <b>Usage Example:</b>
      Suppose we wish to register a directory for entry create, delete, and modify
      events:
      </p><pre>          Path dir = ...
          WatchService watcher = ...
          WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
      </pre>
      @param   watcher
               The watch service to which this object is to be registered
      @param   events
               The events for which this object should be registered
      @return  A key representing the registration of this object with the
               given watch service
      @throws  UnsupportedOperationException
               If unsupported events are specified
      @throws  IllegalArgumentException
               If an invalid combination of events is specified
      @throws  ClosedWatchServiceException
               If the watch service is closed
      @throws  NotDirectoryException
               If the file is registered to watch the entries in a directory
               and the file is not a directory  <i>(optional specific exception)</i>
      @throws  IOException
               If an I/O error occurs
      @throws  SecurityException
               In the case of the default provider, and a security manager is
               installed, the {@link SecurityManager#checkRead(String) checkRead}
               method is invoked to check read access to the file.</div>
<a id="L708" name="L708"></a> 708     @<a href="../S/1740.html#L51" title="Defined at 51 in src/java/lang/Override.java.">Override</a>
<a id="L709" name="L709"></a> 709     <a href="../S/1934.html#L84" title="Defined at 84 in src/java/nio/file/WatchKey.java.">WatchKey</a> <a href="../R/25749.html" title="Multiple referred from 136 places.">register</a>(<a href="../S/1912.html#L106" title="Defined at 106 in src/java/nio/file/WatchService.java.">WatchService</a> watcher,
<a id="L710" name="L710"></a> 710                       <a href="../S/1916.html#L47" title="Defined at 47 in src/java/nio/file/WatchEvent.java.">WatchEvent</a>.<a href="../D/4856.html" title="Multiple defined in 7 places.">Kind</a>&lt;?&gt;... events)
<a id="L711" name="L711"></a> 711         <strong class="reserved">throws</strong> <a href="../S/1392.html#L39" title="Defined at 39 in src/java/io/IOException.java.">IOException</a>;
<a id="L712" name="L712"></a> 712 
<a id="L713" name="L713"></a> 713     <em class="comment">// -- Iterable --</em>
<a id="L714" name="L714"></a> 714 
<div class="comment">
      Returns an iterator over the name elements of this path.
      <p> The first element returned by the iterator represents the name
      element that is closest to the root in the directory hierarchy, the
      second element is the next closest, and so on. The last element returned
      is the name of the file or directory denoted by this path. The {@link
      #getRoot root} component, if present, is not returned by the iterator.
      @return  an iterator over the name elements of this path.</p></div>
<a id="L726" name="L726"></a> 726     @<a href="../S/1740.html#L51" title="Defined at 51 in src/java/lang/Override.java.">Override</a>
<a id="L727" name="L727"></a> 727     <a href="../D/4461.html" title="Multiple defined in 3 places.">Iterator</a>&lt;<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a>&gt; <a href="../R/22304.html" title="Multiple referred from 905 places.">iterator</a>();
<a id="L728" name="L728"></a> 728 
<a id="L729" name="L729"></a> 729     <em class="comment">// -- compareTo/equals/hashCode --</em>
<a id="L730" name="L730"></a> 730 
<div class="comment">
      Compares two abstract paths lexicographically. The ordering defined by
      this method is provider specific, and in the case of the default
      provider, platform specific. This method does not access the file system
      and neither file is required to exist.
      <p> This method may not be used to compare paths that are associated
      with different file system providers.
      @param   other  the path compared to this path.
      @return  zero if the argument is {@link #equals equal} to this path, a
               value less than zero if this path is lexicographically less than
               the argument, or a value greater than zero if this path is
               lexicographically greater than the argument
      @throws  ClassCastException
               if the paths are associated with different providers</p></div>
<a id="L750" name="L750"></a> 750     @<a href="../S/1740.html#L51" title="Defined at 51 in src/java/lang/Override.java.">Override</a>
<a id="L751" name="L751"></a> 751     <strong class="reserved">int</strong> <a href="../R/11724.html" title="Multiple referred from 291 places.">compareTo</a>(<a href="../S/1949.html#L98" title="Defined at 98 in src/java/nio/file/Path.java.">Path</a> other);
<a id="L752" name="L752"></a> 752 
<div class="comment">
      Tests this path for equality with the given object.
      <p> If the given object is not a Path, or is a Path associated with a
      different <code>FileSystem</code>, then this method returns <code>false</code>.
      </p><p> Whether or not two path are equal depends on the file system
      implementation. In some cases the paths are compared without regard
      to case, and others are case sensitive. This method does not access the
      file system and the file is not required to exist. Where required, the
      {@link Files#isSameFile isSameFile} method may be used to check if two
      paths locate the same file.
      </p><p> This method satisfies the general contract of the {@link
      java.lang.Object#equals(Object) Object.equals} method. </p>
      @param   other
               the object to which this object is to be compared
      @return  <code>true</code> if, and only if, the given object is a <code>Path</code>
               that is identical to this <code>Path</code></div>
<a id="L775" name="L775"></a> 775     <strong class="reserved">boolean</strong> <a href="../R/13992.html" title="Multiple referred from 5400 places.">equals</a>(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> other);
<a id="L776" name="L776"></a> 776 
<div class="comment">
      Computes a hash code for this path.
      <p> The hash code is based upon the components of the path, and
      satisfies the general contract of the {@link Object#hashCode
      Object.hashCode} method.
      @return  the hash-code value for this path</p></div>
<a id="L786" name="L786"></a> 786     <strong class="reserved">int</strong> <a href="../R/20298.html" title="Multiple referred from 715 places.">hashCode</a>();
<a id="L787" name="L787"></a> 787 
<div class="comment">
      Returns the string representation of this path.
      <p> If this path was created by converting a path string using the
      {@link FileSystem#getPath getPath} method then the path string returned
      by this method may differ from the original String used to create the path.
      </p><p> The returned path string uses the default name {@link
      FileSystem#getSeparator separator} to separate names in the path.
      @return  the string representation of this path</p></div>
<a id="L800" name="L800"></a> 800     <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../R/29337.html" title="Multiple referred from 3013 places.">toString</a>();
<a id="L801" name="L801"></a> 801 <em class="brace">}</em>
</pre>
<hr>
<div class="comment">
/* [&lt;][&gt;]<a href="#L106">[^]</a><a href="#L800">[v]</a><a href="#TOP">[top]</a>[bottom]<a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
</body></html>