<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>src/java/util/concurrent/CountedCompleter.java</title>
<meta name="robots" content="noindex,nofollow">
<meta name="generator" content="GLOBAL-6.6.3">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
<a id="TOP" name="TOP"></a><div class="comment">
/* [&lt;][&gt;]<a href="#L453">[^]</a><a href="#L753">[v]</a>[top]<a href="#BOTTOM">[bottom]</a><a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
<hr>
<h2 class="header">DEFINITIONS</h2>
This source file includes following definitions.
<ol>
<li><a href="#L453" title="Defined at 453.">compute</a></li>
<li><a href="#L467" title="Defined at 467.">onCompletion</a></li>
<li><a href="#L488" title="Defined at 488.">onExceptionalCompletion</a></li>
<li><a href="#L498" title="Defined at 498.">getCompleter</a></li>
<li><a href="#L507" title="Defined at 507.">getPendingCount</a></li>
<li><a href="#L516" title="Defined at 516.">setPendingCount</a></li>
<li><a href="#L525" title="Defined at 525.">addToPendingCount</a></li>
<li><a href="#L537" title="Defined at 537.">compareAndSetPendingCount</a></li>
<li><a href="#L547" title="Defined at 547.">decrementPendingCountUnlessZero</a></li>
<li><a href="#L560" title="Defined at 560.">getRoot</a></li>
<li><a href="#L573" title="Defined at 573.">tryComplete</a></li>
<li><a href="#L597" title="Defined at 597.">propagateCompletion</a></li>
<li><a href="#L630" title="Defined at 630.">complete</a></li>
<li><a href="#L647" title="Defined at 647.">firstComplete</a></li>
<li><a href="#L673" title="Defined at 673.">nextComplete</a></li>
<li><a href="#L686" title="Defined at 686.">quietlyCompleteRoot</a></li>
<li><a href="#L705" title="Defined at 705.">helpComplete</a></li>
<li><a href="#L719" title="Defined at 719.">internalPropagateException</a></li>
<li><a href="#L730" title="Defined at 730.">exec</a></li>
<li><a href="#L744" title="Defined at 744.">getRawResult</a></li>
<li><a href="#L753" title="Defined at 753.">setRawResult</a></li>
</ol>
<hr>
<pre>
<div class="comment">
  ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</div>
<a id="L24" name="L24"></a>  24 
<div class="comment">
  Written by Doug Lea with assistance from members of JCP JSR-166
  Expert Group and released to the public domain, as explained at
  http://creativecommons.org/publicdomain/zero/1.0/</div>
<a id="L35" name="L35"></a>  35 
<a id="L36" name="L36"></a>  36 <strong class="reserved">package</strong> <a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.util.concurrent;
<a id="L37" name="L37"></a>  37 
<div class="comment">
  A <a href="../S/1101.html#L212" title="Defined at 212 in src/java/util/concurrent/ForkJoinTask.java.">ForkJoinTask</a> with a completion action performed when
  triggered and there are no remaining pending actions.
  CountedCompleters are in general more robust in the
  presence of subtask stalls and blockage than are other forms of
  ForkJoinTasks, but are less intuitive to program.  Uses of
  CountedCompleter are similar to those of other completion based
  components (such as {@link java.nio.channels.CompletionHandler})
  except that multiple <em>pending</em> completions may be necessary
  to trigger the completion action {@link #onCompletion(CountedCompleter)},
  not just one.
  Unless initialized otherwise, the {@linkplain #getPendingCount pending
  count} starts at zero, but may be (atomically) changed using
  methods <a href="#L516" title="Defined at 516.">setPendingCount</a>, <a href="#L525" title="Defined at 525.">addToPendingCount</a>, and
  <a href="#L537" title="Defined at 537.">compareAndSetPendingCount</a>. Upon invocation of {@link
  #tryComplete}, if the pending action count is nonzero, it is
  decremented; otherwise, the completion action is performed, and if
  this completer itself has a completer, the process is continued
  with its completer.  As is the case with related synchronization
  components such as {@link java.util.concurrent.Phaser Phaser} and
  {@link java.util.concurrent.Semaphore Semaphore}, these methods
  affect only internal counts; they do not establish any further
  internal bookkeeping. In particular, the identities of pending
  tasks are not maintained. As illustrated below, you can create
  subclasses that do record some or all pending tasks or their
  results when needed.  As illustrated below, utility methods
  supporting customization of completion traversals are also
  provided. However, because CountedCompleters provide only basic
  synchronization mechanisms, it may be useful to create further
  abstract subclasses that maintain linkages, fields, and additional
  support methods appropriate for a set of related usages.
  <p>A concrete CountedCompleter class must define method {@link
  #compute}, that should in most cases (as illustrated below), invoke
  <code>tryComplete()</code> once before returning. The class may also
  optionally override method {@link #onCompletion(CountedCompleter)}
  to perform an action upon normal completion, and method
  {@link #onExceptionalCompletion(Throwable, CountedCompleter)} to
  perform an action upon any exception.
  </p><p>CountedCompleters most often do not bear results, in which case
  they are normally declared as <code>CountedCompleter<void></void></code>, and
  will always return <code>null</code> as a result value.  In other cases,
  you should override method <a href="#L744" title="Defined at 744.">getRawResult</a> to provide a
  result from <code>join(), invoke()</code>, and related methods.  In
  general, this method should return the value of a field (or a
  function of one or more fields) of the CountedCompleter object that
  holds the result upon completion. Method <a href="#L753" title="Defined at 753.">setRawResult</a> by
  default plays no role in CountedCompleters.  It is possible, but
  rarely applicable, to override this method to maintain other
  objects or fields holding result data.
  </p><p>A CountedCompleter that does not itself have a completer (i.e.,
  one for which <a href="#L498" title="Defined at 498.">getCompleter</a> returns <code>null</code>) can be
  used as a regular ForkJoinTask with this added functionality.
  However, any completer that in turn has another completer serves
  only as an internal helper for other computations, so its own task
  status (as reported in methods such as {@link ForkJoinTask#isDone})
  is arbitrary; this status changes only upon explicit invocations of
  <a href="#L630" title="Defined at 630.">complete</a>, {@link ForkJoinTask#cancel},
  {@link ForkJoinTask#completeExceptionally(Throwable)} or upon
  exceptional completion of method <code>compute</code>. Upon any
  exceptional completion, the exception may be relayed to a task's
  completer (and its completer, and so on), if one exists and it has
  not otherwise already completed. Similarly, cancelling an internal
  CountedCompleter has only a local effect on that completer, so is
  not often useful.
  </p><p><b>Sample Usages.</b>
  </p><p><b>Parallel recursive decomposition.</b> CountedCompleters may
  be arranged in trees similar to those often used with {@link
  RecursiveAction}s, although the constructions involved in setting
  them up typically vary. Here, the completer of each task is its
  parent in the computation tree. Even though they entail a bit more
  bookkeeping, CountedCompleters may be better choices when applying
  a possibly time-consuming operation (that cannot be further
  subdivided) to each element of an array or collection; especially
  when the operation takes a significantly different amount of time
  to complete for some elements than others, either because of
  intrinsic variation (for example I/O) or auxiliary effects such as
  garbage collection.  Because CountedCompleters provide their own
  continuations, other threads need not block waiting to perform
  them.
  </p><p>For example, here is an initial version of a class that uses
  divide-by-two recursive decomposition to divide work into single
  pieces (leaf tasks). Even when work is split into individual calls,
  tree-based techniques are usually preferable to directly forking
  leaf tasks, because they reduce inter-thread communication and
  improve load balancing. In the recursive case, the second of each
  pair of subtasks to finish triggers completion of its parent
  (because no result combination is performed, the default no-op
  implementation of method <code>onCompletion</code> is not overridden).
  A static utility method sets up the base task and invokes it
  (here, implicitly using the {@link ForkJoinPool#commonPool()}).
  </p><pre> {@code
  class MyOperation<e> { void apply(E e) { ... }  }
  class ForEach<e> extends CountedCompleter<void> {
    public static <e> void forEach(E[] array, MyOperation<e> op) {
      new ForEach<e>(null, array, op, 0, array.length).invoke();
    }
    final E[] array; final MyOperation<e> op; final int lo, hi;
    ForEach(CountedCompleter<!--?--> p, E[] array, MyOperation<e> op, int lo, int hi) {
      super(p);
      this.array = array; this.op = op; this.lo = lo; this.hi = hi;
    }
    public void compute() { // version 1
      if (hi - lo &gt;= 2) {
        int mid = (lo + hi) &gt;&gt;&gt; 1;
        setPendingCount(2); // must set pending count before fork
        new ForEach(this, array, op, mid, hi).fork(); // right child
        new ForEach(this, array, op, lo, mid).fork(); // left child
      }
      else if (hi &gt; lo)
        op.apply(array[lo]);
      tryComplete();
    }
  }}</e></e></e></e></e></void></e></e></pre>
  This design can be improved by noticing that in the recursive case,
  the task has nothing to do after forking its right task, so can
  directly invoke its left task before returning. (This is an analog
  of tail recursion removal.)  Also, because the task returns upon
  executing its left task (rather than falling through to invoke
  <code>tryComplete</code>) the pending count is set to one:
  <pre> {@code
  class ForEach<e> ...
    public void compute() { // version 2
      if (hi - lo &gt;= 2) {
        int mid = (lo + hi) &gt;&gt;&gt; 1;
        setPendingCount(1); // only one pending
        new ForEach(this, array, op, mid, hi).fork(); // right child
        new ForEach(this, array, op, lo, mid).compute(); // direct invoke
      }
      else {
        if (hi &gt; lo)
          op.apply(array[lo]);
        tryComplete();
      }
    }
  }</e></pre>
  As a further improvement, notice that the left task need not even exist.
  Instead of creating a new one, we can iterate using the original task,
  and add a pending count for each fork.  Additionally, because no task
  in this tree implements an {@link #onCompletion(CountedCompleter)} method,
  <code>tryComplete()</code> can be replaced with <a href="#L597" title="Defined at 597.">propagateCompletion</a>.
  <pre> {@code
  class ForEach<e> ...
    public void compute() { // version 3
      int l = lo,  h = hi;
      while (h - l &gt;= 2) {
        int mid = (l + h) &gt;&gt;&gt; 1;
        addToPendingCount(1);
        new ForEach(this, array, op, mid, h).fork(); // right child
        h = mid;
      }
      if (h &gt; l)
        op.apply(array[l]);
      propagateCompletion();
    }
  }</e></pre>
  Additional improvements of such classes might entail precomputing
  pending counts so that they can be established in constructors,
  specializing classes for leaf steps, subdividing by say, four,
  instead of two per iteration, and using an adaptive threshold
  instead of always subdividing down to single elements.
  <p><b>Searching.</b> A tree of CountedCompleters can search for a
  value or property in different parts of a data structure, and
  report a result in an {@link
  java.util.concurrent.atomic.AtomicReference AtomicReference} as
  soon as one is found. The others can poll the result to avoid
  unnecessary work. (You could additionally {@linkplain #cancel
  cancel} other tasks, but it is usually simpler and more efficient
  to just let them notice that the result is set and if so skip
  further processing.)  Illustrating again with an array using full
  partitioning (again, in practice, leaf tasks will almost always
  process more than one element):
  </p><pre> {@code
  class Searcher<e> extends CountedCompleter<e> {
    final E[] array; final AtomicReference<e> result; final int lo, hi;
    Searcher(CountedCompleter<!--?--> p, E[] array, AtomicReference<e> result, int lo, int hi) {
      super(p);
      this.array = array; this.result = result; this.lo = lo; this.hi = hi;
    }
    public E getRawResult() { return result.get(); }
    public void compute() { // similar to ForEach version 3
      int l = lo,  h = hi;
      while (result.get() == null &amp;&amp; h &gt;= l) {
        if (h - l &gt;= 2) {
          int mid = (l + h) &gt;&gt;&gt; 1;
          addToPendingCount(1);
          new Searcher(this, array, result, mid, h).fork();
          h = mid;
        }
        else {
          E x = array[l];
          if (matches(x) &amp;&amp; result.compareAndSet(null, x))
            quietlyCompleteRoot(); // root task is now joinable
          break;
        }
      }
      tryComplete(); // normally complete whether or not found
    }
    boolean matches(E e) { ... } // return true if found
    public static <e> E search(E[] array) {
        return new Searcher<e>(null, array, new AtomicReference<e>(), 0, array.length).invoke();
    }
  }}</e></e></e></e></e></e></e></pre>
  In this example, as well as others in which tasks have no other
  effects except to compareAndSet a common result, the trailing
  unconditional invocation of <code>tryComplete</code> could be made
  conditional (<code>if (result.get() == null) tryComplete();</code>)
  because no further bookkeeping is required to manage completions
  once the root task completes.
  <p><b>Recording subtasks.</b> CountedCompleter tasks that combine
  results of multiple subtasks usually need to access these results
  in method {@link #onCompletion(CountedCompleter)}. As illustrated in the following
  class (that performs a simplified form of map-reduce where mappings
  and reductions are all of type <code>E</code>), one way to do this in
  divide and conquer designs is to have each subtask record its
  sibling, so that it can be accessed in method <code>onCompletion</code>.
  This technique applies to reductions in which the order of
  combining left and right results does not matter; ordered
  reductions require explicit left/right designations.  Variants of
  other streamlinings seen in the above examples may also apply.
  </p><pre> {@code
  class MyMapper<e> { E apply(E v) {  ...  } }
  class MyReducer<e> { E apply(E x, E y) {  ...  } }
  class MapReducer<e> extends CountedCompleter<e> {
    final E[] array; final MyMapper<e> mapper;
    final MyReducer<e> reducer; final int lo, hi;
    MapReducer<e> sibling;
    E result;
    MapReducer(CountedCompleter<!--?--> p, E[] array, MyMapper<e> mapper,
               MyReducer<e> reducer, int lo, int hi) {
      super(p);
      this.array = array; this.mapper = mapper;
      this.reducer = reducer; this.lo = lo; this.hi = hi;
    }
    public void compute() {
      if (hi - lo &gt;= 2) {
        int mid = (lo + hi) &gt;&gt;&gt; 1;
        MapReducer<e> left = new MapReducer(this, array, mapper, reducer, lo, mid);
        MapReducer<e> right = new MapReducer(this, array, mapper, reducer, mid, hi);
        left.sibling = right;
        right.sibling = left;
        setPendingCount(1); // only right is pending
        right.fork();
        left.compute();     // directly execute left
      }
      else {
        if (hi &gt; lo)
            result = mapper.apply(array[lo]);
        tryComplete();
      }
    }
    public void onCompletion(CountedCompleter<!--?--> caller) {
      if (caller != this) {
        MapReducer<e> child = (MapReducer<e>)caller;
        MapReducer<e> sib = child.sibling;
        if (sib == null || sib.result == null)
          result = child.result;
        else
          result = reducer.apply(child.result, sib.result);
      }
    }
    public E getRawResult() { return result; }
    public static <e> E mapReduce(E[] array, MyMapper<e> mapper, MyReducer<e> reducer) {
      return new MapReducer<e>(null, array, mapper, reducer,
                               0, array.length).invoke();
    }
  }}</e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></e></pre>
  Here, method <code>onCompletion</code> takes a form common to many
  completion designs that combine results. This callback-style method
  is triggered once per task, in either of the two different contexts
  in which the pending count is, or becomes, zero: (1) by a task
  itself, if its pending count is zero upon invocation of {@code
  tryComplete}, or (2) by any of its subtasks when they complete and
  decrement the pending count to zero. The <code>caller</code> argument
  distinguishes cases.  Most often, when the caller is <code>this</code>,
  no action is necessary. Otherwise the caller argument can be used
  (usually via a cast) to supply a value (and/or links to other
  values) to be combined.  Assuming proper use of pending counts, the
  actions inside <code>onCompletion</code> occur (once) upon completion of
  a task and its subtasks. No additional synchronization is required
  within this method to ensure thread safety of accesses to fields of
  this task or other completed tasks.
  <p><b>Completion Traversals</b>. If using <code>onCompletion</code> to
  process completions is inapplicable or inconvenient, you can use
  methods <a href="#L647" title="Defined at 647.">firstComplete</a> and <a href="#L673" title="Defined at 673.">nextComplete</a> to create
  custom traversals.  For example, to define a MapReducer that only
  splits out right-hand tasks in the form of the third ForEach
  example, the completions must cooperatively reduce along
  unexhausted subtask links, which can be done as follows:
  </p><pre> {@code
  class MapReducer<e> extends CountedCompleter<e> { // version 2
    final E[] array; final MyMapper<e> mapper;
    final MyReducer<e> reducer; final int lo, hi;
    MapReducer<e> forks, next; // record subtask forks in list
    E result;
    MapReducer(CountedCompleter<!--?--> p, E[] array, MyMapper<e> mapper,
               MyReducer<e> reducer, int lo, int hi, MapReducer<e> next) {
      super(p);
      this.array = array; this.mapper = mapper;
      this.reducer = reducer; this.lo = lo; this.hi = hi;
      this.next = next;
    }
    public void compute() {
      int l = lo,  h = hi;
      while (h - l &gt;= 2) {
        int mid = (l + h) &gt;&gt;&gt; 1;
        addToPendingCount(1);
        (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();
        h = mid;
      }
      if (h &gt; l)
        result = mapper.apply(array[l]);
      // process completions by reducing along and advancing subtask links
      for (CountedCompleter<!--?--> c = firstComplete(); c != null; c = c.nextComplete()) {
        for (MapReducer t = (MapReducer)c, s = t.forks;  s != null; s = t.forks = s.next)
          t.result = reducer.apply(t.result, s.result);
      }
    }
    public E getRawResult() { return result; }
    public static <e> E mapReduce(E[] array, MyMapper<e> mapper, MyReducer<e> reducer) {
      return new MapReducer<e>(null, array, mapper, reducer,
                               0, array.length, null).invoke();
    }
  }}</e></e></e></e></e></e></e></e></e></e></e></e></pre>
  <p><b>Triggers.</b> Some CountedCompleters are themselves never
  forked, but instead serve as bits of plumbing in other designs;
  including those in which the completion of one or more async tasks
  triggers another async task. For example:
  </p><pre> {@code
  class HeaderBuilder extends CountedCompleter&lt;...&gt; { ... }
  class BodyBuilder extends CountedCompleter&lt;...&gt; { ... }
  class PacketSender extends CountedCompleter&lt;...&gt; {
    PacketSender(...) { super(null, 1); ... } // trigger on second completion
    public void compute() { } // never called
    public void onCompletion(CountedCompleter<!--?--> caller) { sendPacket(); }
  }
  // sample use:
  PacketSender p = new PacketSender();
  new HeaderBuilder(p, ...).fork();
  new BodyBuilder(p, ...).fork();
  }</pre>
  @since 1.8
  @author Doug Lea</div>
<a id="L411" name="L411"></a> 411 <strong class="reserved">public</strong> <strong class="reserved">abstract</strong> <strong class="reserved">class</strong> <a href="../R/1786.html" title="Multiple referred from 125 places.">CountedCompleter</a>&lt;<a href="../D/8701.html" title="Multiple defined in 3 places.">T</a>&gt; <strong class="reserved">extends</strong> <a href="../S/1101.html#L212" title="Defined at 212 in src/java/util/concurrent/ForkJoinTask.java.">ForkJoinTask</a>&lt;<a href="../D/8701.html" title="Multiple defined in 3 places.">T</a>&gt; <em class="brace">{</em>
<a id="L412" name="L412"></a> 412     <strong class="reserved">private</strong> <strong class="reserved">static</strong> <strong class="reserved">final</strong> <strong class="reserved">long</strong> serialVersionUID = 5232453752276485070L;
<a id="L413" name="L413"></a> 413 
<div class="comment">
     /** This task's completer, or null if none */</div>
<a id="L415" name="L415"></a> 415     <strong class="reserved">final</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; completer;
<div class="comment">
     /** The number of pending tasks until completion */</div>
<a id="L417" name="L417"></a> 417     <strong class="reserved">volatile</strong> <strong class="reserved">int</strong> pending;
<a id="L418" name="L418"></a> 418 
<div class="comment">
      Creates a new CountedCompleter with the given completer
      and initial pending count.
      @param completer this task's completer, or <code>null</code> if none
      @param initialPendingCount the initial pending count</div>
<a id="L426" name="L426"></a> 426     <strong class="reserved">protected</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>(CountedCompleter&lt;?&gt; completer,
<a id="L427" name="L427"></a> 427                                <strong class="reserved">int</strong> initialPendingCount) <em class="brace">{</em>
<a id="L428" name="L428"></a> 428         <strong class="reserved">this</strong>.completer = completer;
<a id="L429" name="L429"></a> 429         <strong class="reserved">this</strong>.pending = initialPendingCount;
<a id="L430" name="L430"></a> 430     <em class="brace">}</em>
<a id="L431" name="L431"></a> 431 
<div class="comment">
      Creates a new CountedCompleter with the given completer
      and an initial pending count of zero.
      @param completer this task's completer, or <code>null</code> if none</div>
<a id="L438" name="L438"></a> 438     <strong class="reserved">protected</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>(CountedCompleter&lt;?&gt; completer) <em class="brace">{</em>
<a id="L439" name="L439"></a> 439         <strong class="reserved">this</strong>.completer = completer;
<a id="L440" name="L440"></a> 440     <em class="brace">}</em>
<a id="L441" name="L441"></a> 441 
<div class="comment">
      Creates a new CountedCompleter with no completer
      and an initial pending count of zero.</div>
<a id="L446" name="L446"></a> 446     <strong class="reserved">protected</strong> CountedCompleter() <em class="brace">{</em>
<a id="L447" name="L447"></a> 447         <strong class="reserved">this</strong>.completer = <strong class="reserved">null</strong>;
<a id="L448" name="L448"></a> 448     <em class="brace">}</em>
<a id="L449" name="L449"></a> 449 
<div class="comment">
      The main computation performed by this task.</div>
<a id="L453" name="L453"></a> 453     <strong class="reserved">public</strong> <strong class="reserved">abstract</strong> <strong class="reserved">void</strong> <a href="../R/11810.html" title="Multiple referred from 7 places.">compute</a>();
<a id="L454" name="L454"></a> 454 
<div class="comment">
      Performs an action when method <a href="#L573" title="Defined at 573.">tryComplete</a> is invoked
      and the pending count is zero, or when the unconditional
      method <a href="#L630" title="Defined at 630.">complete</a> is invoked.  By default, this method
      does nothing. You can distinguish cases by checking the
      identity of the given caller argument. If not equal to {@code
      this}, then it is typically a subtask that may contain results
      (and/or links to other results) to combine.
      @param caller the task invoking this method (which may
      be this task itself)</div>
<a id="L467" name="L467"></a> 467     <strong class="reserved">public</strong> <strong class="reserved">void</strong> <a href="../R/23948.html" title="Multiple referred from 6 places.">onCompletion</a>(<a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; caller) <em class="brace">{</em>
<a id="L468" name="L468"></a> 468     <em class="brace">}</em>
<a id="L469" name="L469"></a> 469 
<div class="comment">
      Performs an action when method {@link
      #completeExceptionally(Throwable)} is invoked or method {@link
      #compute} throws an exception, and this task has not already
      otherwise completed normally. On entry to this method, this task
      {@link ForkJoinTask#isCompletedAbnormally}.  The return value
      of this method controls further propagation: If <code>true</code>
      and this task has a completer that has not completed, then that
      completer is also completed exceptionally, with the same
      exception as this completer.  The default implementation of
      this method does nothing except return <code>true</code>.
      @param ex the exception
      @param caller the task invoking this method (which may
      be this task itself)
      @return <code>true</code> if this exception should be propagated to this
      task's completer, if one exists</div>
<a id="L488" name="L488"></a> 488     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> <a href="../S/1070.html#L721" title="Referred from 721 in src/java/util/concurrent/CountedCompleter.java.">onExceptionalCompletion</a>(<a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a> <a href="../S/5015.html#L111" title="Defined at 111 in src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java.">ex</a>, <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; caller) <em class="brace">{</em>
<a id="L489" name="L489"></a> 489         <strong class="reserved">return</strong> <strong class="reserved">true</strong>;
<a id="L490" name="L490"></a> 490     <em class="brace">}</em>
<a id="L491" name="L491"></a> 491 
<div class="comment">
      Returns the completer established in this task's constructor,
      or <code>null</code> if none.
      @return the completer</div>
<a id="L498" name="L498"></a> 498     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../R/15710.html" title="Multiple referred from 5 places.">getCompleter</a>() <em class="brace">{</em>
<a id="L499" name="L499"></a> 499         <strong class="reserved">return</strong> completer;
<a id="L500" name="L500"></a> 500     <em class="brace">}</em>
<a id="L501" name="L501"></a> 501 
<div class="comment">
      Returns the current pending count.
      @return the current pending count</div>
<a id="L507" name="L507"></a> 507     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">int</strong> <a href="../R/18324.html" title="Multiple referred from 17 places.">getPendingCount</a>() <em class="brace">{</em>
<a id="L508" name="L508"></a> 508         <strong class="reserved">return</strong> pending;
<a id="L509" name="L509"></a> 509     <em class="brace">}</em>
<a id="L510" name="L510"></a> 510 
<div class="comment">
      Sets the pending count to the given value.
      @param count the count</div>
<a id="L516" name="L516"></a> 516     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">void</strong> <a href="../R/27926.html" title="Multiple referred from 4 places.">setPendingCount</a>(<strong class="reserved">int</strong> <a href="../D/13557.html" title="Multiple defined in 24 places.">count</a>) <em class="brace">{</em>
<a id="L517" name="L517"></a> 517         pending = <a href="../D/13557.html" title="Multiple defined in 24 places.">count</a>;
<a id="L518" name="L518"></a> 518     <em class="brace">}</em>
<a id="L519" name="L519"></a> 519 
<div class="comment">
      Adds (atomically) the given value to the pending count.
      @param delta the value to add</div>
<a id="L525" name="L525"></a> 525     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">void</strong> <a href="../R/10006.html" title="Multiple referred from 45 places.">addToPendingCount</a>(<strong class="reserved">int</strong> delta) <em class="brace">{</em>
<a id="L526" name="L526"></a> 526         U.getAndAddInt(<strong class="reserved">this</strong>, PENDING, delta);
<a id="L527" name="L527"></a> 527     <em class="brace">}</em>
<a id="L528" name="L528"></a> 528 
<div class="comment">
      Sets (atomically) the pending count to the given count only if
      it currently holds the given expected value.
      @param expected the expected value
      @param count the new value
      @return <code>true</code> if successful</div>
<a id="L537" name="L537"></a> 537     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">boolean</strong> <a href="../R/11698.html" title="Multiple referred from 20 places.">compareAndSetPendingCount</a>(<strong class="reserved">int</strong> expected, <strong class="reserved">int</strong> <a href="../D/13557.html" title="Multiple defined in 24 places.">count</a>) <em class="brace">{</em>
<a id="L538" name="L538"></a> 538         <strong class="reserved">return</strong> U.compareAndSwapInt(<strong class="reserved">this</strong>, PENDING, expected, <a href="../D/13557.html" title="Multiple defined in 24 places.">count</a>);
<a id="L539" name="L539"></a> 539     <em class="brace">}</em>
<a id="L540" name="L540"></a> 540 
<div class="comment">
      If the pending count is nonzero, (atomically) decrements it.
      @return the initial (undecremented) pending count holding on entry
      to this method</div>
<a id="L547" name="L547"></a> 547     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">int</strong> decrementPendingCountUnlessZero() <em class="brace">{</em>
<a id="L548" name="L548"></a> 548         <strong class="reserved">int</strong> <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>;
<a id="L549" name="L549"></a> 549         <strong class="reserved">do</strong> <em class="brace">{</em><em class="brace">}</em> <strong class="reserved">while</strong> ((<a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> = pending) != 0 &amp;&amp;
<a id="L550" name="L550"></a> 550                      !U.compareAndSwapInt(<strong class="reserved">this</strong>, PENDING, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> - 1));
<a id="L551" name="L551"></a> 551         <strong class="reserved">return</strong> <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>;
<a id="L552" name="L552"></a> 552     <em class="brace">}</em>
<a id="L553" name="L553"></a> 553 
<div class="comment">
      Returns the root of the current computation; i.e., this
      task if it has no completer, else its completer's root.
      @return the root of the current computation</div>
<a id="L560" name="L560"></a> 560     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../R/18758.html" title="Multiple referred from 54 places.">getRoot</a>() <em class="brace">{</em>
<a id="L561" name="L561"></a> 561         <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = <strong class="reserved">this</strong>, p;
<a id="L562" name="L562"></a> 562         <strong class="reserved">while</strong> ((p = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.completer) != <strong class="reserved">null</strong>)
<a id="L563" name="L563"></a> 563             <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = p;
<a id="L564" name="L564"></a> 564         <strong class="reserved">return</strong> <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>;
<a id="L565" name="L565"></a> 565     <em class="brace">}</em>
<a id="L566" name="L566"></a> 566 
<div class="comment">
      If the pending count is nonzero, decrements the count;
      otherwise invokes {@link #onCompletion(CountedCompleter)}
      and then similarly tries to complete this task's completer,
      if one exists, else marks this task as complete.</div>
<a id="L573" name="L573"></a> 573     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">void</strong> <a href="../R/29545.html" title="Multiple referred from 37 places.">tryComplete</a>() <em class="brace">{</em>
<a id="L574" name="L574"></a> 574         <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = <strong class="reserved">this</strong>, s = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>;
<a id="L575" name="L575"></a> 575         <strong class="reserved">for</strong> (<strong class="reserved">int</strong> <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>;;) <em class="brace">{</em>
<a id="L576" name="L576"></a> 576             <strong class="reserved">if</strong> ((<a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.pending) == 0) <em class="brace">{</em>
<a id="L577" name="L577"></a> 577                 <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.<a href="../D/28487.html" title="Multiple defined in 8 places.">onCompletion</a>(s);
<a id="L578" name="L578"></a> 578                 <strong class="reserved">if</strong> ((<a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = (s = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>).completer) == <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L579" name="L579"></a> 579                     s.<a href="../S/1101.html#L984" title="Defined at 984 in src/java/util/concurrent/ForkJoinTask.java.">quietlyComplete</a>();
<a id="L580" name="L580"></a> 580                     <strong class="reserved">return</strong>;
<a id="L581" name="L581"></a> 581                 <em class="brace">}</em>
<a id="L582" name="L582"></a> 582             <em class="brace">}</em>
<a id="L583" name="L583"></a> 583             <strong class="reserved">else</strong> <strong class="reserved">if</strong> (U.compareAndSwapInt(<a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>, PENDING, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> - 1))
<a id="L584" name="L584"></a> 584                 <strong class="reserved">return</strong>;
<a id="L585" name="L585"></a> 585         <em class="brace">}</em>
<a id="L586" name="L586"></a> 586     <em class="brace">}</em>
<a id="L587" name="L587"></a> 587 
<div class="comment">
      Equivalent to <a href="#L573" title="Defined at 573.">tryComplete</a> but does not invoke {@link
      #onCompletion(CountedCompleter)} along the completion path:
      If the pending count is nonzero, decrements the count;
      otherwise, similarly tries to complete this task's completer, if
      one exists, else marks this task as complete. This method may be
      useful in cases where <code>onCompletion</code> should not, or need
      not, be invoked for each completer in a computation.</div>
<a id="L597" name="L597"></a> 597     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">void</strong> <a href="../R/25218.html" title="Multiple referred from 15 places.">propagateCompletion</a>() <em class="brace">{</em>
<a id="L598" name="L598"></a> 598         <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = <strong class="reserved">this</strong>, s = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>;
<a id="L599" name="L599"></a> 599         <strong class="reserved">for</strong> (<strong class="reserved">int</strong> <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>;;) <em class="brace">{</em>
<a id="L600" name="L600"></a> 600             <strong class="reserved">if</strong> ((<a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.pending) == 0) <em class="brace">{</em>
<a id="L601" name="L601"></a> 601                 <strong class="reserved">if</strong> ((<a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = (s = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>).completer) == <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L602" name="L602"></a> 602                     s.<a href="../S/1101.html#L984" title="Defined at 984 in src/java/util/concurrent/ForkJoinTask.java.">quietlyComplete</a>();
<a id="L603" name="L603"></a> 603                     <strong class="reserved">return</strong>;
<a id="L604" name="L604"></a> 604                 <em class="brace">}</em>
<a id="L605" name="L605"></a> 605             <em class="brace">}</em>
<a id="L606" name="L606"></a> 606             <strong class="reserved">else</strong> <strong class="reserved">if</strong> (U.compareAndSwapInt(<a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>, PENDING, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> - 1))
<a id="L607" name="L607"></a> 607                 <strong class="reserved">return</strong>;
<a id="L608" name="L608"></a> 608         <em class="brace">}</em>
<a id="L609" name="L609"></a> 609     <em class="brace">}</em>
<a id="L610" name="L610"></a> 610 
<div class="comment">
      Regardless of pending count, invokes
      {@link #onCompletion(CountedCompleter)}, marks this task as
      complete and further triggers <a href="#L573" title="Defined at 573.">tryComplete</a> on this
      task's completer, if one exists.  The given rawResult is
      used as an argument to <a href="#L753" title="Defined at 753.">setRawResult</a> before invoking
      {@link #onCompletion(CountedCompleter)} or marking this task
      as complete; its value is meaningful only for classes
      overriding <code>setRawResult</code>.  This method does not modify
      the pending count.
      <p>This method may be useful when forcing completion as soon as
      any one (versus all) of several subtask results are obtained.
      However, in the common (and recommended) case in which {@code
      setRawResult} is not overridden, this effect can be obtained
      more simply using <code>quietlyCompleteRoot();</code>.
      @param rawResult the raw result</p></div>
<a id="L630" name="L630"></a> 630     <strong class="reserved">public</strong> <strong class="reserved">void</strong> <a href="../R/11771.html" title="Multiple referred from 58 places.">complete</a>(<a href="../D/8701.html" title="Multiple defined in 3 places.">T</a> rawResult) <em class="brace">{</em>
<a id="L631" name="L631"></a> 631         <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; p;
<a id="L632" name="L632"></a> 632         <a href="../D/33659.html" title="Multiple defined in 13 places.">setRawResult</a>(rawResult);
<a id="L633" name="L633"></a> 633         <a href="../D/28487.html" title="Multiple defined in 8 places.">onCompletion</a>(<strong class="reserved">this</strong>);
<a id="L634" name="L634"></a> 634         <a href="../S/1101.html#L984" title="Defined at 984 in src/java/util/concurrent/ForkJoinTask.java.">quietlyComplete</a>();
<a id="L635" name="L635"></a> 635         <strong class="reserved">if</strong> ((p = completer) != <strong class="reserved">null</strong>)
<a id="L636" name="L636"></a> 636             p.<a href="../S/1070.html#L573" title="Defined at 573 in src/java/util/concurrent/CountedCompleter.java.">tryComplete</a>();
<a id="L637" name="L637"></a> 637     <em class="brace">}</em>
<a id="L638" name="L638"></a> 638 
<div class="comment">
      If this task's pending count is zero, returns this task;
      otherwise decrements its pending count and returns {@code
      null}. This method is designed to be used with {@link
      #nextComplete} in completion traversal loops.
      @return this task, if pending count was zero, else <code>null</code></div>
<a id="L647" name="L647"></a> 647     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../R/14630.html" title="Multiple referred from 20 places.">firstComplete</a>() <em class="brace">{</em>
<a id="L648" name="L648"></a> 648         <strong class="reserved">for</strong> (<strong class="reserved">int</strong> <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>;;) <em class="brace">{</em>
<a id="L649" name="L649"></a> 649             <strong class="reserved">if</strong> ((<a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> = pending) == 0)
<a id="L650" name="L650"></a> 650                 <strong class="reserved">return</strong> <strong class="reserved">this</strong>;
<a id="L651" name="L651"></a> 651             <strong class="reserved">else</strong> <strong class="reserved">if</strong> (U.compareAndSwapInt(<strong class="reserved">this</strong>, PENDING, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a>, <a href="../S/986.html#L3167" title="Defined at 3167 in src/java/util/regex/Pattern.java.">c</a> - 1))
<a id="L652" name="L652"></a> 652                 <strong class="reserved">return</strong> <strong class="reserved">null</strong>;
<a id="L653" name="L653"></a> 653         <em class="brace">}</em>
<a id="L654" name="L654"></a> 654     <em class="brace">}</em>
<a id="L655" name="L655"></a> 655 
<div class="comment">
      If this task does not have a completer, invokes {@link
      ForkJoinTask#quietlyComplete} and returns <code>null</code>.  Or, if
      the completer's pending count is non-zero, decrements that
      pending count and returns <code>null</code>.  Otherwise, returns the
      completer.  This method can be used as part of a completion
      traversal loop for homogeneous task hierarchies:
      <pre> {@code
      for (CountedCompleter<!--?--> c = firstComplete();
           c != null;
           c = c.nextComplete()) {
        // ... process c ...
      }}</pre>
      @return the completer, or <code>null</code> if none</div>
<a id="L673" name="L673"></a> 673     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../R/23657.html" title="Multiple referred from 19 places.">nextComplete</a>() <em class="brace">{</em>
<a id="L674" name="L674"></a> 674         <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; p;
<a id="L675" name="L675"></a> 675         <strong class="reserved">if</strong> ((p = completer) != <strong class="reserved">null</strong>)
<a id="L676" name="L676"></a> 676             <strong class="reserved">return</strong> p.<a href="../S/1070.html#L647" title="Defined at 647 in src/java/util/concurrent/CountedCompleter.java.">firstComplete</a>();
<a id="L677" name="L677"></a> 677         <strong class="reserved">else</strong> <em class="brace">{</em>
<a id="L678" name="L678"></a> 678             <a href="../S/1101.html#L984" title="Defined at 984 in src/java/util/concurrent/ForkJoinTask.java.">quietlyComplete</a>();
<a id="L679" name="L679"></a> 679             <strong class="reserved">return</strong> <strong class="reserved">null</strong>;
<a id="L680" name="L680"></a> 680         <em class="brace">}</em>
<a id="L681" name="L681"></a> 681     <em class="brace">}</em>
<a id="L682" name="L682"></a> 682 
<div class="comment">
      Equivalent to <code>getRoot().quietlyComplete()</code>.</div>
<a id="L686" name="L686"></a> 686     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">void</strong> <a href="../R/25385.html" title="Multiple referred from 4 places.">quietlyCompleteRoot</a>() <em class="brace">{</em>
<a id="L687" name="L687"></a> 687         <strong class="reserved">for</strong> (<a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = <strong class="reserved">this</strong>, p;;) <em class="brace">{</em>
<a id="L688" name="L688"></a> 688             <strong class="reserved">if</strong> ((p = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.completer) == <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L689" name="L689"></a> 689                 <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.<a href="../S/1101.html#L984" title="Defined at 984 in src/java/util/concurrent/ForkJoinTask.java.">quietlyComplete</a>();
<a id="L690" name="L690"></a> 690                 <strong class="reserved">return</strong>;
<a id="L691" name="L691"></a> 691             <em class="brace">}</em>
<a id="L692" name="L692"></a> 692             <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = p;
<a id="L693" name="L693"></a> 693         <em class="brace">}</em>
<a id="L694" name="L694"></a> 694     <em class="brace">}</em>
<a id="L695" name="L695"></a> 695 
<div class="comment">
      If this task has not completed, attempts to process at most the
      given number of other unprocessed tasks for which this task is
      on the completion path, if any are known to exist.
      @param maxTasks the maximum number of tasks to process.  If
                      less than or equal to zero, then no tasks are
                      processed.</div>
<a id="L705" name="L705"></a> 705     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">void</strong> <a href="../R/20310.html" title="Multiple referred from 3 places.">helpComplete</a>(<strong class="reserved">int</strong> maxTasks) <em class="brace">{</em>
<a id="L706" name="L706"></a> 706         <a href="../S/1769.html#L141" title="Defined at 141 in src/java/lang/Thread.java.">Thread</a> t; <a href="../S/1113.html#L55" title="Defined at 55 in src/java/util/concurrent/ForkJoinWorkerThread.java.">ForkJoinWorkerThread</a> wt;
<a id="L707" name="L707"></a> 707         <strong class="reserved">if</strong> (maxTasks &gt; 0 &amp;&amp; <a href="../S/2277.html#L669" title="Defined at 669 in src/java/awt/image/PixelGrabber.java.">status</a> &gt;= 0) <em class="brace">{</em>
<a id="L708" name="L708"></a> 708             <strong class="reserved">if</strong> ((t = <a href="../S/1769.html#L141" title="Defined at 141 in src/java/lang/Thread.java.">Thread</a>.<a href="../S/1769.html#L264" title="Defined at 264 in src/java/lang/Thread.java.">currentThread</a>()) <strong class="reserved">instanceof</strong> <a href="../S/1113.html#L55" title="Defined at 55 in src/java/util/concurrent/ForkJoinWorkerThread.java.">ForkJoinWorkerThread</a>)
<a id="L709" name="L709"></a> 709                 (wt = (<a href="../S/1113.html#L55" title="Defined at 55 in src/java/util/concurrent/ForkJoinWorkerThread.java.">ForkJoinWorkerThread</a>)t).pool.
<a id="L710" name="L710"></a> 710                     <a href="../D/24232.html" title="Multiple defined in 2 places.">helpComplete</a>(wt.workQueue, <strong class="reserved">this</strong>, maxTasks);
<a id="L711" name="L711"></a> 711             <strong class="reserved">else</strong>
<a id="L712" name="L712"></a> 712                 <a href="../S/1063.html#L170" title="Defined at 170 in src/java/util/concurrent/ForkJoinPool.java.">ForkJoinPool</a>.common.<a href="../S/1063.html#L2463" title="Defined at 2463 in src/java/util/concurrent/ForkJoinPool.java.">externalHelpComplete</a>(<strong class="reserved">this</strong>, maxTasks);
<a id="L713" name="L713"></a> 713         <em class="brace">}</em>
<a id="L714" name="L714"></a> 714     <em class="brace">}</em>
<a id="L715" name="L715"></a> 715 
<div class="comment">
      Supports ForkJoinTask exception propagation.</div>
<a id="L719" name="L719"></a> 719     <strong class="reserved">void</strong> <a href="../S/1101.html#L493" title="Referred from 493 in src/java/util/concurrent/ForkJoinTask.java.">internalPropagateException</a>(<a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a> <a href="../S/5015.html#L111" title="Defined at 111 in src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java.">ex</a>) <em class="brace">{</em>
<a id="L720" name="L720"></a> 720         <a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>&lt;?&gt; <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = <strong class="reserved">this</strong>, s = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>;
<a id="L721" name="L721"></a> 721         <strong class="reserved">while</strong> (<a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.<a href="../S/1070.html#L488" title="Defined at 488 in src/java/util/concurrent/CountedCompleter.java.">onExceptionalCompletion</a>(<a href="../S/5015.html#L111" title="Defined at 111 in src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java.">ex</a>, s) &amp;&amp;
<a id="L722" name="L722"></a> 722                (<a href="../D/10513.html" title="Multiple defined in 3 places.">a</a> = (s = <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>).completer) != <strong class="reserved">null</strong> &amp;&amp; <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.<a href="../S/2277.html#L669" title="Defined at 669 in src/java/awt/image/PixelGrabber.java.">status</a> &gt;= 0 &amp;&amp;
<a id="L723" name="L723"></a> 723                <a href="../D/10513.html" title="Multiple defined in 3 places.">a</a>.<a href="../S/1101.html#L459" title="Defined at 459 in src/java/util/concurrent/ForkJoinTask.java.">recordExceptionalCompletion</a>(<a href="../S/5015.html#L111" title="Defined at 111 in src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java.">ex</a>) == EXCEPTIONAL)
<a id="L724" name="L724"></a> 724             ;
<a id="L725" name="L725"></a> 725     <em class="brace">}</em>
<a id="L726" name="L726"></a> 726 
<div class="comment">
      Implements execution conventions for CountedCompleters.</div>
<a id="L730" name="L730"></a> 730     <strong class="reserved">protected</strong> <strong class="reserved">final</strong> <strong class="reserved">boolean</strong> <a href="../R/14091.html" title="Multiple referred from 8 places.">exec</a>() <em class="brace">{</em>
<a id="L731" name="L731"></a> 731         <a href="../D/13161.html" title="Multiple defined in 74 places.">compute</a>();
<a id="L732" name="L732"></a> 732         <strong class="reserved">return</strong> <strong class="reserved">false</strong>;
<a id="L733" name="L733"></a> 733     <em class="brace">}</em>
<a id="L734" name="L734"></a> 734 
<div class="comment">
      Returns the result of the computation. By default
      returns <code>null</code>, which is appropriate for <code>Void</code>
      actions, but in other cases should be overridden, almost
      always to return a field or function of a field that
      holds the result upon completion.
      @return the result of the computation</div>
<a id="L744" name="L744"></a> 744     <strong class="reserved">public</strong> <a href="../D/8701.html" title="Multiple defined in 3 places.">T</a> <a href="../R/18601.html" title="Multiple referred from 4 places.">getRawResult</a>() <em class="brace">{</em> <strong class="reserved">return</strong> <strong class="reserved">null</strong>; <em class="brace">}</em>
<a id="L745" name="L745"></a> 745 
<div class="comment">
      A method that result-bearing CountedCompleters may optionally
      use to help maintain result data.  By default, does nothing.
      Overrides are not recommended. However, if this method is
      overridden to update existing objects or fields, then it must
      in general be defined to be thread-safe.</div>
<a id="L753" name="L753"></a> 753     <strong class="reserved">protected</strong> <strong class="reserved">void</strong> <a href="../R/27997.html" title="Multiple referred from 2 places.">setRawResult</a>(<a href="../D/8701.html" title="Multiple defined in 3 places.">T</a> t) <em class="brace">{</em> <em class="brace">}</em>
<a id="L754" name="L754"></a> 754 
<a id="L755" name="L755"></a> 755     <em class="comment">// Unsafe mechanics</em>
<a id="L756" name="L756"></a> 756     <strong class="reserved">private</strong> <strong class="reserved">static</strong> <strong class="reserved">final</strong> sun.misc.Unsafe U;
<a id="L757" name="L757"></a> 757     <strong class="reserved">private</strong> <strong class="reserved">static</strong> <strong class="reserved">final</strong> <strong class="reserved">long</strong> PENDING;
<a id="L758" name="L758"></a> 758     <strong class="reserved">static</strong> <em class="brace">{</em>
<a id="L759" name="L759"></a> 759         <strong class="reserved">try</strong> <em class="brace">{</em>
<a id="L760" name="L760"></a> 760             U = sun.misc.Unsafe.getUnsafe();
<a id="L761" name="L761"></a> 761             PENDING = U.<a href="../D/28395.html" title="Multiple defined in 5 places.">objectFieldOffset</a>
<a id="L762" name="L762"></a> 762                 (<a href="../S/1070.html#L411" title="Defined at 411 in src/java/util/concurrent/CountedCompleter.java.">CountedCompleter</a>.<strong class="reserved">class</strong>.<a href="../S/1722.html#L2065" title="Defined at 2065 in src/java/lang/Class.java.">getDeclaredField</a>("pending"));
<a id="L763" name="L763"></a> 763         <em class="brace">}</em> <strong class="reserved">catch</strong> (<a href="../S/1582.html#L45" title="Defined at 45 in src/java/lang/Exception.java.">Exception</a> e) <em class="brace">{</em>
<a id="L764" name="L764"></a> 764             <strong class="reserved">throw</strong> <strong class="reserved">new</strong> <a href="../S/1772.html#L49" title="Defined at 49 in src/java/lang/Error.java.">Error</a>(e);
<a id="L765" name="L765"></a> 765         <em class="brace">}</em>
<a id="L766" name="L766"></a> 766     <em class="brace">}</em>
<a id="L767" name="L767"></a> 767 <em class="brace">}</em>
</pre>
<hr>
<div class="comment">
/* [&lt;][&gt;]<a href="#L453">[^]</a><a href="#L753">[v]</a><a href="#TOP">[top]</a>[bottom]<a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
</body></html>