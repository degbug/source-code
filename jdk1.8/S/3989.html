<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>src/javax/xml/bind/annotation/XmlElementRef.java</title>
<meta name="robots" content="noindex,nofollow">
<meta name="generator" content="GLOBAL-6.6.3">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
<a id="TOP" name="TOP"></a><div class="comment">
/* [&lt;][&gt;]<a href="#L221">[^]</a><a href="#L289">[v]</a>[top]<a href="#BOTTOM">[bottom]</a><a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
<hr>
<h2 class="header">DEFINITIONS</h2>
This source file includes following definitions.
<ol>
<li><a href="#L221" title="Defined at 221.">Retention</a></li>
<li><a href="#L222" title="Defined at 222.">Target</a></li>
<li><a href="#L230" title="Defined at 230.">type</a></li>
<li><a href="#L255" title="Defined at 255.">namespace</a></li>
<li><a href="#L260" title="Defined at 260.">name</a></li>
<li><a href="#L289" title="Defined at 289.">required</a></li>
</ol>
<hr>
<pre>
<div class="comment">
  Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
  ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</div>
<a id="L25" name="L25"></a>  25 
<a id="L26" name="L26"></a>  26 <strong class="reserved">package</strong> <a href="../D/26637.html" title="Multiple defined in 6 places.">javax</a>.xml.<a href="../D/11844.html" title="Multiple defined in 44 places.">bind</a>.annotation;
<a id="L27" name="L27"></a>  27 
<a id="L28" name="L28"></a>  28 <strong class="reserved">import</strong> javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
<a id="L29" name="L29"></a>  29 <strong class="reserved">import</strong> java.lang.annotation.Retention;
<a id="L30" name="L30"></a>  30 <strong class="reserved">import</strong> java.lang.annotation.Target;
<a id="L31" name="L31"></a>  31 
<a id="L32" name="L32"></a>  32 <strong class="reserved">import</strong> static java.lang.annotation.RetentionPolicy.RUNTIME;
<a id="L33" name="L33"></a>  33 <strong class="reserved">import</strong> static java.lang.annotation.ElementType.FIELD;
<a id="L34" name="L34"></a>  34 <strong class="reserved">import</strong> static java.lang.annotation.ElementType.METHOD;
<a id="L35" name="L35"></a>  35 
<div class="comment">
  <p>
  Maps a JavaBean property to a XML element derived from property's type.
  </p><p>
  <b>Usage</b>
  </p><p>
  <tt>@XmlElementRef</tt> annotation can be used with a
  JavaBean property or from within {@link XmlElementRefs}
  </p><p>
  This annotation dynamically associates an XML element name with the JavaBean
  property. When a JavaBean property is annotated with {@link
  XmlElement}, the XML element name is statically derived from the
  JavaBean property name. However, when this annotation is used, the
  XML element name is derived from the instance of the type of the
  JavaBean property at runtime.
  </p><h3> XML Schema substitution group support </h3>
  XML Schema allows a XML document author to use XML element names
  that were not statically specified in the content model of a
  schema using substitution groups. Schema derived code provides
  support for substitution groups using an <i>element property</i>,
  (section 5.5.5, "Element Property" of JAXB 2.0 specification). An
  element property method signature is of the form:
  <pre>      public void setTerm(JAXBElement<!--? extends Operator-->);
      public JAXBElement<!--? extends Operator--> getTerm();
  </pre>
  <p>
  An element factory method annotated with  {@link XmlElementDecl} is
  used to create a <tt>JAXBElement</tt> instance, containing an XML
  element name. The presence of @XmlElementRef annotation on an
  element property indicates that the element name from <tt>JAXBElement</tt>
  instance be used instead of deriving an XML element name from the
  JavaBean property name.
  </p><p>
  The usage is subject to the following constraints:
  </p><ul><li> If the collection item type (for collection property) or
         property type (for single valued property) is
         {@link javax.xml.bind.JAXBElement}, then
         <tt>@XmlElementRef}.name()</tt> and <tt>@XmlElementRef.namespace()</tt> must
         point an element factory method  with an @XmlElementDecl
         annotation in a class annotated  with @XmlRegistry (usually
         ObjectFactory class generated by  the schema compiler) :
         <ul><li> @XmlElementDecl.name() must equal @XmlElementRef.name()  </li><li> @XmlElementDecl.namespace() must equal @XmlElementRef.namespace(). </li>
         </ul>
    </li><li> If the collection item type (for collection property) or
         property type  (for single valued property) is not
         {@link javax.xml.bind.JAXBElement}, then the type referenced by the
         property or field must be annotated  with {@link XmlRootElement}. </li><li> This annotation can be used with the following annotations:
         {@link XmlElementWrapper}, {@link XmlJavaTypeAdapter}.
    </li></ul>
  <p>See "Package Specification" in javax.xml.bind.package javadoc for
  additional common information.</p>
  <p><b>Example 1: Ant Task Example</b></p>
  The following Java class hierarchy models an Ant build
  script.  An Ant task corresponds to a class in the class
  hierarchy. The XML element name of an Ant task is indicated by the
  @XmlRootElement annotation on its corresponding class.
  <pre>      @XmlRootElement(name="target")
      class Target {
          // The presence of @XmlElementRef indicates that the XML
          // element name will be derived from the @XmlRootElement
          // annotation on the type (for e.g. "jar" for JarTask).
          @XmlElementRef
          List&lt;Task&gt; tasks;
      }
      abstract class Task {
      }
      @XmlRootElement(name="jar")
      class JarTask extends Task {
          ...
      }
      @XmlRootElement(name="javac")
      class JavacTask extends Task {
          ...
      }
      &lt;!-- XML Schema fragment --&gt;
      &lt;xs:element name="target" type="Target"&gt;
      &lt;xs:complexType name="Target"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:choice maxOccurs="unbounded"&gt;
            &lt;xs:element ref="jar"&gt;
            &lt;xs:element ref="javac"&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:complexType&gt;
  </pre>
  <p>
  Thus the following code fragment:
  </p><pre>      Target target = new Target();
      target.tasks.add(new JarTask());
      target.tasks.add(new JavacTask());
      marshal(target);
  </pre>
  will produce the following XML output:
  <pre>      &lt;target&gt;
        &lt;jar&gt;
          ....
        &lt;/jar&gt;
        &lt;javac&gt;
          ....
        &lt;/javac&gt;
      &lt;/target&gt;
  </pre>
  <p>
  It is not an error to have a class that extends <tt>Task</tt>
  that doesn't have {@link XmlRootElement}. But they can't show up in an
  XML instance (because they don't have XML element names).
  </p><p><b>Example 2: XML Schema Susbstitution group support</b>
  </p><p> The following example shows the annotations for XML Schema
  substitution groups.  The annotations and the ObjectFactory are
  derived from the schema.
  </p><pre>      @XmlElement
      class Math {
          //  The value of {@link #type()}is
          //  JAXBElement.class , which indicates the XML
          //  element name ObjectFactory - in general a class marked
          //  with @XmlRegistry. (See ObjectFactory below)
          //
          //  The {@link #name()} is "operator", a pointer to a
          // factory method annotated with a
          //  {@link XmlElementDecl} with the name "operator". Since
          //  "operator" is the head of a substitution group that
          //  contains elements "add" and "sub" elements, "operator"
          //  element can be substituted in an instance document by
          //  elements "add" or "sub". At runtime, JAXBElement
          //  instance contains the element name that has been
          //  substituted in the XML document.
          //
          @XmlElementRef(type=JAXBElement.class,name="operator")
          JAXBElement&lt;? extends Operator&gt; term;
      }
      @XmlRegistry
      class ObjectFactory {
          @XmlElementDecl(name="operator")
          JAXBElement&lt;Operator&gt; createOperator(Operator o) {...}
          @XmlElementDecl(name="add",substitutionHeadName="operator")
          JAXBElement&lt;Operator&gt; createAdd(Operator o) {...}
          @XmlElementDecl(name="sub",substitutionHeadName="operator")
          JAXBElement&lt;Operator&gt; createSub(Operator o) {...}
      }
      class Operator {
          ...
      }
  </pre>
  <p>
  Thus, the following code fragment
  </p><pre>      Math m = new Math();
      m.term = new ObjectFactory().createAdd(new Operator());
      marshal(m);
  </pre>
  will produce the following XML output:
  <pre>      &lt;math&gt;
        &lt;add&gt;...&lt;/add&gt;
      &lt;/math&gt;
  </pre>
  @author <ul><li>Kohsuke Kawaguchi, Sun Microsystems,Inc. </li><li>Sekhar Vajjhala, Sun Microsystems, Inc.</li></ul>
  @see XmlElementRefs
  @since JAXB2.0</div>
<a id="L221" name="L221"></a> 221 @<a href="../R/6706.html" title="Multiple referred from 50 places.">Retention</a>(<a href="../S/1697.html#L164" title="Defined at 164 in src/java/lang/management/PlatformComponent.java.">RUNTIME</a>)
<a id="L222" name="L222"></a> 222 @<a href="../R/8028.html" title="Multiple referred from 50 places.">Target</a>(<em class="brace">{</em>FIELD,<a href="../S/6524.html#L183" title="Defined at 183 in src/com/sun/source/tree/Tree.java.">METHOD</a><em class="brace">}</em>)
<a id="L223" name="L223"></a> 223 <strong class="reserved">public</strong> @<strong class="reserved">interface</strong> <a href="../R/9282.html" title="Multiple referred from 2 places.">XmlElementRef</a> <em class="brace">{</em>
<div class="comment">
      The Java type being referenced.
      <p>
      If the value is DEFAULT.class, the type is inferred from the
      the type of the JavaBean property.</p></div>
<a id="L230" name="L230"></a> 230     <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a> <a href="../R/29570.html" title="Multiple referred from 5977 places.">type</a>() <strong class="reserved">default</strong> <a href="../D/2015.html" title="Multiple defined in 7 places.">DEFAULT</a>.<strong class="reserved">class</strong>;
<a id="L231" name="L231"></a> 231 
<div class="comment">
      This parameter and {@link #name()} are used to determine the
      XML element for the JavaBean property.
      <p> If <tt>type()</tt> is <tt>JAXBElement.class</tt> , then
      <tt>namespace()</tt> and <tt>name()</tt>
      point to a factory method with {@link XmlElementDecl}. The XML
      element name is the element name from the factory method's
      {@link XmlElementDecl} annotation or if an element from its
      substitution group (of which it is a head element) has been
      substituted in the XML document, then the element name is from the
      {@link XmlElementDecl} on the substituted element.
      </p><p> If {@link #type()} is not <tt>JAXBElement.class</tt>, then
      the XML element name is the XML element name statically
      associated with the type using the annotation {@link
      XmlRootElement} on the type. If the type is not annotated with
      an {@link XmlElementDecl}, then it is an error.
      </p><p> If <tt>type()</tt> is not <tt>JAXBElement.class</tt>, then
      this value must be "".</p></div>
<a id="L255" name="L255"></a> 255     <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../R/23435.html" title="Multiple referred from 554 places.">namespace</a>() <strong class="reserved">default</strong> "";
<div class="comment">
      @see #namespace()</div>
<a id="L260" name="L260"></a> 260     <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../R/23424.html" title="Multiple referred from 9102 places.">name</a>() <strong class="reserved">default</strong> "##default";
<a id="L261" name="L261"></a> 261 
<div class="comment">
      Used in {@link XmlElementRef#type()} to
      signal that the type be inferred from the signature
      of the property.</div>
<a id="L267" name="L267"></a> 267     <strong class="reserved">static</strong> <strong class="reserved">final</strong> <strong class="reserved">class</strong> <a href="../R/1852.html" title="Multiple referred from 41 places.">DEFAULT</a> <em class="brace">{</em><em class="brace">}</em>
<a id="L268" name="L268"></a> 268 
<div class="comment">
      Customize the element declaration to be required.
      <p>
      If required() is true, then Javabean property is mapped to
      an XML schema element declaration with minOccurs="1".
      maxOccurs is "1" for a single valued property and "unbounded"
      for a multivalued property.
      </p><p>
      If required() is false, then the Javabean property is mapped
      to XML Schema element declaration with minOccurs="0".
      maxOccurs is "1" for a single valued property and "unbounded"
      for a multivalued property.
      </p><p>
      For compatibility with JAXB 2.1, this property defaults to <tt>true</tt>,
      despite the fact that {@link XmlElement#required()} defaults to false.
      @since 2.2</p></div>
<a id="L289" name="L289"></a> 289     <strong class="reserved">boolean</strong> <a href="../R/26230.html" title="Multiple referred from 53 places.">required</a>() <strong class="reserved">default</strong> <strong class="reserved">true</strong>;
<a id="L290" name="L290"></a> 290 <em class="brace">}</em>
</pre>
<hr>
<div class="comment">
/* [&lt;][&gt;]<a href="#L221">[^]</a><a href="#L289">[v]</a><a href="#TOP">[top]</a>[bottom]<a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
</body></html>