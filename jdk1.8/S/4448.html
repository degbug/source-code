<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>src/javax/sql/rowset/CachedRowSet.java</title>
<meta name="robots" content="noindex,nofollow">
<meta name="generator" content="GLOBAL-6.6.3">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
<a id="TOP" name="TOP"></a><div class="comment">
/* [&lt;][&gt;]<a href="#L655">[^]</a><a href="#L1622">[v]</a>[top]<a href="#BOTTOM">[bottom]</a><a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
<hr>
<h2 class="header">DEFINITIONS</h2>
This source file includes following definitions.
<ol>
<li><a href="#L655" title="Defined at 655.">populate</a></li>
<li><a href="#L684" title="Defined at 684.">execute</a></li>
<li><a href="#L747" title="Defined at 747.">acceptChanges</a></li>
<li><a href="#L817" title="Defined at 817.">acceptChanges</a></li>
<li><a href="#L838" title="Defined at 838.">restoreOriginal</a></li>
<li><a href="#L872" title="Defined at 872.">release</a></li>
<li><a href="#L895" title="Defined at 895.">undoDelete</a></li>
<li><a href="#L920" title="Defined at 920.">undoInsert</a></li>
<li><a href="#L941" title="Defined at 941.">undoUpdate</a></li>
<li><a href="#L954" title="Defined at 954.">columnUpdated</a></li>
<li><a href="#L969" title="Defined at 969.">columnUpdated</a></li>
<li><a href="#L1009" title="Defined at 1009.">toCollection</a></li>
<li><a href="#L1038" title="Defined at 1038.">toCollection</a></li>
<li><a href="#L1067" title="Defined at 1067.">toCollection</a></li>
<li><a href="#L1104" title="Defined at 1104.">getSyncProvider</a></li>
<li><a href="#L1131" title="Defined at 1131.">setSyncProvider</a></li>
<li><a href="#L1139" title="Defined at 1139.">size</a></li>
<li><a href="#L1157" title="Defined at 1157.">setMetaData</a></li>
<li><a href="#L1186" title="Defined at 1186.">getOriginal</a></li>
<li><a href="#L1205" title="Defined at 1205.">getOriginalRow</a></li>
<li><a href="#L1221" title="Defined at 1221.">setOriginalRow</a></li>
<li><a href="#L1236" title="Defined at 1236.">getTableName</a></li>
<li><a href="#L1258" title="Defined at 1258.">setTableName</a></li>
<li><a href="#L1274" title="Defined at 1274.">getKeyColumns</a></li>
<li><a href="#L1297" title="Defined at 1297.">setKeyColumns</a></li>
<li><a href="#L1331" title="Defined at 1331.">createShared</a></li>
<li><a href="#L1355" title="Defined at 1355.">createCopy</a></li>
<li><a href="#L1381" title="Defined at 1381.">createCopySchema</a></li>
<li><a href="#L1407" title="Defined at 1407.">createCopyNoConstraints</a></li>
<li><a href="#L1423" title="Defined at 1423.">getRowSetWarnings</a></li>
<li><a href="#L1449" title="Defined at 1449.">getShowDeleted</a></li>
<li><a href="#L1471" title="Defined at 1471.">setShowDeleted</a></li>
<li><a href="#L1488" title="Defined at 1488.">commit</a></li>
<li><a href="#L1501" title="Defined at 1501.">rollback</a></li>
<li><a href="#L1516" title="Defined at 1516.">rollback</a></li>
<li><a href="#L1546" title="Defined at 1546.">rowSetPopulated</a></li>
<li><a href="#L1576" title="Defined at 1576.">populate</a></li>
<li><a href="#L1589" title="Defined at 1589.">setPageSize</a></li>
<li><a href="#L1596" title="Defined at 1596.">getPageSize</a></li>
<li><a href="#L1608" title="Defined at 1608.">nextPage</a></li>
<li><a href="#L1622" title="Defined at 1622.">previousPage</a></li>
</ol>
<hr>
<pre>
<div class="comment">
  Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</div>
<a id="L25" name="L25"></a>  25 
<a id="L26" name="L26"></a>  26 <strong class="reserved">package</strong> <a href="../D/26637.html" title="Multiple defined in 6 places.">javax</a>.sql.rowset;
<a id="L27" name="L27"></a>  27 
<a id="L28" name="L28"></a>  28 <strong class="reserved">import</strong> java.sql.*;
<a id="L29" name="L29"></a>  29 <strong class="reserved">import</strong> javax.sql.*;
<a id="L30" name="L30"></a>  30 <strong class="reserved">import</strong> javax.naming.*;
<a id="L31" name="L31"></a>  31 <strong class="reserved">import</strong> java.io.*;
<a id="L32" name="L32"></a>  32 <strong class="reserved">import</strong> java.math.*;
<a id="L33" name="L33"></a>  33 <strong class="reserved">import</strong> java.util.*;
<a id="L34" name="L34"></a>  34 
<a id="L35" name="L35"></a>  35 <strong class="reserved">import</strong> javax.sql.rowset.spi.*;
<a id="L36" name="L36"></a>  36 
<div class="comment">
  The interface that all standard implementations of
  <code>CachedRowSet</code> must implement.
  <p>
  The reference implementation of the <code>CachedRowSet</code> interface provided
  by Oracle Corporation is a standard implementation. Developers may use this implementation
  just as it is, they may extend it, or they may choose to write their own implementations
  of this interface.
  </p><p>
  A <code>CachedRowSet</code> object is a container for rows of data
  that caches its rows in memory, which makes it possible to operate without always being
  connected to its data source. Further, it is a
  JavaBeans™ component and is scrollable,
  updatable, and serializable. A <code>CachedRowSet</code> object typically
  contains rows from a result set, but it can also contain rows from any file
  with a tabular format, such as a spread sheet.  The reference implementation
  supports getting data only from a <code>ResultSet</code> object, but
  developers can extend the <code>SyncProvider</code> implementations to provide
  access to other tabular data sources.
  </p><p>
  An application can modify the data in a <code>CachedRowSet</code> object, and
  those modifications can then be propagated back to the source of the data.
  </p><p>
  A <code>CachedRowSet</code> object is a <i>disconnected</i> rowset, which means
  that it makes use of a connection to its data source only briefly. It connects to its
  data source while it is reading data to populate itself with rows and again
  while it is propagating changes back to its underlying data source. The rest
  of the time, a <code>CachedRowSet</code> object is disconnected, including
  while its data is being modified. Being disconnected makes a <code>RowSet</code>
  object much leaner and therefore much easier to pass to another component.  For
  example, a disconnected <code>RowSet</code> object can be serialized and passed
  over the wire to a thin client such as a personal digital assistant (PDA).
  </p><h3>1.0 Creating a <code>CachedRowSet</code> Object</h3>
  The following line of code uses the default constructor for
  <code>CachedRowSet</code>
  supplied in the reference implementation (RI) to create a default
  <code>CachedRowSet</code> object.
  <pre>      CachedRowSetImpl crs = new CachedRowSetImpl();
  </pre>
  This new <code>CachedRowSet</code> object will have its properties set to the
  default properties of a <code>BaseRowSet</code> object, and, in addition, it will
  have an <code>RIOptimisticProvider</code> object as its synchronization provider.
  <code>RIOptimisticProvider</code>, one of two <code>SyncProvider</code>
  implementations included in the RI, is the default provider that the
  <code>SyncFactory</code> singleton will supply when no synchronization
  provider is specified.
  <p>
  A <code>SyncProvider</code> object provides a <code>CachedRowSet</code> object
  with a reader (a <code>RowSetReader</code> object) for reading data from a
  data source to populate itself with data. A reader can be implemented to read
  data from a <code>ResultSet</code> object or from a file with a tabular format.
  A <code>SyncProvider</code> object also provides
  a writer (a <code>RowSetWriter</code> object) for synchronizing any
  modifications to the <code>CachedRowSet</code> object's data made while it was
  disconnected with the data in the underlying data source.
  </p><p>
  A writer can be implemented to exercise various degrees of care in checking
  for conflicts and in avoiding them.
  (A conflict occurs when a value in the data source has been changed after
  the rowset populated itself with that value.)
  The <code>RIOptimisticProvider</code> implementation assumes there will be
  few or no conflicts and therefore sets no locks. It updates the data source
  with values from the <code>CachedRowSet</code> object only if there are no
  conflicts.
  Other writers can be implemented so that they always write modified data to
  the data source, which can be accomplished either by not checking for conflicts
  or, on the other end of the spectrum, by setting locks sufficient to prevent data
  in the data source from being changed. Still other writer implementations can be
  somewhere in between.
  </p><p>
  A <code>CachedRowSet</code> object may use any
  <code>SyncProvider</code> implementation that has been registered
  with the <code>SyncFactory</code> singleton. An application
  can find out which <code>SyncProvider</code> implementations have been
  registered by calling the following line of code.
  </p><pre>       java.util.Enumeration providers = SyncFactory.getRegisteredProviders();
  </pre>
  <p>
  There are two ways for a <code>CachedRowSet</code> object to specify which
  <code>SyncProvider</code> object it will use.
  </p><ul>
      <li>Supplying the name of the implementation to the constructor<br>
      The following line of code creates the <code>CachedRowSet</code>
      object <i>crs2</i> that is initialized with default values except that its
      <code>SyncProvider</code> object is the one specified.
      <pre>           CachedRowSetImpl crs2 = new CachedRowSetImpl(
                                  "com.fred.providers.HighAvailabilityProvider");
      </pre>
      </li><li>Setting the <code>SyncProvider</code> using the <code>CachedRowSet</code>
          method <code>setSyncProvider</code><br>
       The following line of code resets the <code>SyncProvider</code> object
       for <i>crs</i>, the <code>CachedRowSet</code> object created with the
       default constructor.
       <pre>            crs.setSyncProvider("com.fred.providers.HighAvailabilityProvider");
       </pre>
  </li></ul>
  See the comments for <code>SyncFactory</code> and <code>SyncProvider</code> for
  more details.
  <h3>2.0 Retrieving Data from a <code>CachedRowSet</code> Object</h3>
  Data is retrieved from a <code>CachedRowSet</code> object by using the
  getter methods inherited from the <code>ResultSet</code>
  interface.  The following examples, in which <code>crs</code> is a
  <code>CachedRowSet</code>
  object, demonstrate how to iterate through the rows, retrieving the column
  values in each row.  The first example uses the version of the
  getter methods that take a column number; the second example
  uses the version that takes a column name. Column numbers are generally
  used when the <code>RowSet</code> object's command
  is of the form <code>SELECT * FROM TABLENAME</code>; column names are most
  commonly used when the command specifies columns by name.
  <pre>     while (crs.next()) {
         String name = crs.getString(1);
         int id = crs.getInt(2);
         Clob comment = crs.getClob(3);
         short dept = crs.getShort(4);
         System.out.println(name + "  " + id + "  " + comment + "  " + dept);
     }
  </pre>
  <pre>     while (crs.next()) {
         String name = crs.getString("NAME");
         int id = crs.getInt("ID");
         Clob comment = crs.getClob("COM");
         short dept = crs.getShort("DEPT");
         System.out.println(name + "  " + id + "  " + comment + "  " + dept);
     }
  </pre>
  <h4>2.1 Retrieving <code>RowSetMetaData</code></h4>
  An application can get information about the columns in a <code>CachedRowSet</code>
  object by calling <code>ResultSetMetaData</code> and <code>RowSetMetaData</code>
  methods on a <code>RowSetMetaData</code> object. The following code fragment,
  in which <i>crs</i> is a <code>CachedRowSet</code> object, illustrates the process.
  The first line creates a <code>RowSetMetaData</code> object with information
  about the columns in <i>crs</i>.  The method <code>getMetaData</code>,
  inherited from the <code>ResultSet</code> interface, returns a
  <code>ResultSetMetaData</code> object, which is cast to a
  <code>RowSetMetaData</code> object before being assigned to the variable
  <i>rsmd</i>.  The second line finds out how many columns <i>jrs</i> has, and
  the third line gets the JDBC type of values stored in the second column of
  <code>jrs</code>.
  <pre>      RowSetMetaData rsmd = (RowSetMetaData)crs.getMetaData();
      int count = rsmd.getColumnCount();
      int type = rsmd.getColumnType(2);
  </pre>
  The <code>RowSetMetaData</code> interface differs from the
  <code>ResultSetMetaData</code> interface in two ways.
  <ul>
    <li><i>It includes <code>setter</code> methods:</i> A <code>RowSet</code>
    object uses these methods internally when it is populated with data from a
    different <code>ResultSet</code> object.
    </li><li><i>It contains fewer <code>getter</code> methods:</i> Some
    <code>ResultSetMetaData</code> methods to not apply to a <code>RowSet</code>
    object. For example, methods retrieving whether a column value is writable
    or read only do not apply because all of a <code>RowSet</code> object's
    columns will be writable or read only, depending on whether the rowset is
    updatable or not.
  </li></ul>
  NOTE: In order to return a <code>RowSetMetaData</code> object, implementations must
  override the <code>getMetaData()</code> method defined in
  <code>java.sql.ResultSet</code> and return a <code>RowSetMetaData</code> object.
  <h3>3.0 Updating a <code>CachedRowSet</code> Object</h3>
  Updating a <code>CachedRowSet</code> object is similar to updating a
  <code>ResultSet</code> object, but because the rowset is not connected to
  its data source while it is being updated, it must take an additional step
  to effect changes in its underlying data source. After calling the method
  <code>updateRow</code> or <code>insertRow</code>, a
  <code>CachedRowSet</code>
  object must also call the method <code>acceptChanges</code> to have updates
  written to the data source. The following example, in which the cursor is
  on a row in the <code>CachedRowSet</code> object <i>crs</i>, shows
  the code required to update two column values in the current row and also
  update the <code>RowSet</code> object's underlying data source.
  <pre>      crs.updateShort(3, 58);
      crs.updateInt(4, 150000);
      crs.updateRow();
      crs.acceptChanges();
  </pre>
  <p>
  The next example demonstrates moving to the insert row, building a new
  row on the insert row, inserting it into the rowset, and then calling the
  method <code>acceptChanges</code> to add the new row to the underlying data
  source.  Note that as with the getter methods, the  updater methods may take
  either a column index or a column name to designate the column being acted upon.
  </p><pre>      crs.moveToInsertRow();
      crs.updateString("Name", "Shakespeare");
      crs.updateInt("ID", 10098347);
      crs.updateShort("Age", 58);
      crs.updateInt("Sal", 150000);
      crs.insertRow();
      crs.moveToCurrentRow();
      crs.acceptChanges();
  </pre>
  <p>
  NOTE: Where the <code>insertRow()</code> method inserts the contents of a
  <code>CachedRowSet</code> object's insert row is implementation-defined.
  The reference implementation for the <code>CachedRowSet</code> interface
  inserts a new row immediately following the current row, but it could be
  implemented to insert new rows in any number of other places.
  </p><p>
  Another thing to note about these examples is how they use the method
  <code>acceptChanges</code>.  It is this method that propagates changes in
  a <code>CachedRowSet</code> object back to the underlying data source,
  calling on the <code>RowSet</code> object's writer internally to write
  changes to the data source. To do this, the writer has to incur the expense
  of establishing a connection with that data source. The
  preceding two code fragments call the method <code>acceptChanges</code>
  immediately after calling <code>updateRow</code> or <code>insertRow</code>.
  However, when there are multiple rows being changed, it is more efficient to call
  <code>acceptChanges</code> after all calls to <code>updateRow</code>
  and <code>insertRow</code> have been made.  If <code>acceptChanges</code>
  is called only once, only one connection needs to be established.
  </p><h3>4.0 Updating the Underlying Data Source</h3>
  When the method <code>acceptChanges</code> is executed, the
  <code>CachedRowSet</code> object's writer, a <code>RowSetWriterImpl</code>
  object, is called behind the scenes to write the changes made to the
  rowset to the underlying data source. The writer is implemented to make a
  connection to the data source and write updates to it.
  <p>
  A writer is made available through an implementation of the
  <code>SyncProvider</code> interface, as discussed in section 1,
  "Creating a <code>CachedRowSet</code> Object."
  The default reference implementation provider, <code>RIOptimisticProvider</code>,
  has its writer implemented to use an optimistic concurrency control
  mechanism. That is, it maintains no locks in the underlying database while
  the rowset is disconnected from the database and simply checks to see if there
  are any conflicts before writing data to the data source.  If there are any
  conflicts, it does not write anything to the data source.
  </p><p>
  The reader/writer facility
  provided by the <code>SyncProvider</code> class is pluggable, allowing for the
  customization of data retrieval and updating. If a different concurrency
  control mechanism is desired, a different implementation of
  <code>SyncProvider</code> can be plugged in using the method
  <code>setSyncProvider</code>.
  </p><p>
  In order to use the optimistic concurrency control routine, the
  <code>RIOptismisticProvider</code> maintains both its current
  value and its original value (the value it had immediately preceding the
  current value). Note that if no changes have been made to the data in a
  <code>RowSet</code> object, its current values and its original values are the same,
  both being the values with which the <code>RowSet</code> object was initially
  populated.  However, once any values in the <code>RowSet</code> object have been
  changed, the current values and the original values will be different, though at
  this stage, the original values are still the initial values. With any subsequent
  changes to data in a <code>RowSet</code> object, its original values and current
  values will still differ, but its original values will be the values that
  were previously the current values.
  </p><p>
  Keeping track of original values allows the writer to compare the <code>RowSet</code>
  object's original value with the value in the database. If the values in
  the database differ from the <code>RowSet</code> object's original values, which means that
  the values in the database have been changed, there is a conflict.
  Whether a writer checks for conflicts, what degree of checking it does, and how
  it handles conflicts all depend on how it is implemented.
  </p><h3>5.0 Registering and Notifying Listeners</h3>
  Being JavaBeans components, all rowsets participate in the JavaBeans event
  model, inheriting methods for registering listeners and notifying them of
  changes from the <code>BaseRowSet</code> class.  A listener for a
  <code>CachedRowSet</code> object is a component that wants to be notified
  whenever there is a change in the rowset.  For example, if a
  <code>CachedRowSet</code> object contains the results of a query and
  those
  results are being displayed in, say, a table and a bar graph, the table and
  bar graph could be registered as listeners with the rowset so that they can
  update themselves to reflect changes. To become listeners, the table and
  bar graph classes must implement the <code>RowSetListener</code> interface.
  Then they can be added to the <code>CachedRowSet</code> object's list of
  listeners, as is illustrated in the following lines of code.
  <pre>     crs.addRowSetListener(table);
     crs.addRowSetListener(barGraph);
  </pre>
  Each <code>CachedRowSet</code> method that moves the cursor or changes
  data also notifies registered listeners of the changes, so
  <code>table</code> and <code>barGraph</code> will be notified when there is
  a change in <code>crs</code>.
  <h3>6.0 Passing Data to Thin Clients</h3>
  One of the main reasons to use a <code>CachedRowSet</code> object is to
  pass data between different components of an application. Because it is
  serializable, a <code>CachedRowSet</code> object can be used, for example,
  to send the result of a query executed by an enterprise JavaBeans component
  running in a server environment over a network to a client running in a
  web browser.
  <p>
  While a <code>CachedRowSet</code> object is disconnected, it can be much
  leaner than a <code>ResultSet</code> object with the same data.
  As a result, it can be especially suitable for sending data to a thin client
  such as a PDA, where it would be inappropriate to use a JDBC driver
  due to resource limitations or security considerations.
  Thus, a <code>CachedRowSet</code> object provides a means to "get rows in"
  without the need to implement the full JDBC API.
  </p><h3>7.0 Scrolling and Updating</h3>
  A second major use for <code>CachedRowSet</code> objects is to provide
  scrolling and updating for <code>ResultSet</code> objects that
  do not provide these capabilities themselves.  In other words, a
  <code>CachedRowSet</code> object can be used to augment the
  capabilities of a JDBC technology-enabled driver (hereafter called a
  "JDBC driver") when the DBMS does not provide full support for scrolling and
  updating. To achieve the effect of making a non-scrollble and read-only
  <code>ResultSet</code> object scrollable and updatable, a programmer
  simply needs to create a <code>CachedRowSet</code> object populated
  with that <code>ResultSet</code> object's data.  This is demonstrated
  in the following code fragment, where <code>stmt</code> is a
  <code>Statement</code> object.
  <pre>     ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
     CachedRowSetImpl crs = new CachedRowSetImpl();
     crs.populate(rs);
  </pre>
  <p>
  The object <code>crs</code> now contains the data from the table
  <code>EMPLOYEES</code>, just as the object <code>rs</code> does.
  The difference is that the cursor for <code>crs</code> can be moved
  forward, backward, or to a particular row even if the cursor for
  <code>rs</code> can move only forward.  In addition, <code>crs</code> is
  updatable even if <code>rs</code> is not because by default, a
  <code>CachedRowSet</code> object is both scrollable and updatable.
  </p><p>
  In summary, a <code>CachedRowSet</code> object can be thought of as simply
  a disconnected set of rows that are being cached outside of a data source.
  Being thin and serializable, it can easily be sent across a wire,
  and it is well suited to sending data to a thin client. However, a
  <code>CachedRowSet</code> object does have a limitation: It is limited in
  size by the amount of data it can store in memory at one time.
  </p><h3>8.0 Getting Universal Data Access</h3>
  Another advantage of the <code>CachedRowSet</code> class is that it makes it
  possible to retrieve and store data from sources other than a relational
  database. The reader for a rowset can be implemented to read and populate
  its rowset with data from any tabular data source, including a spreadsheet
  or flat file.
  Because both a <code>CachedRowSet</code> object and its metadata can be
  created from scratch, a component that acts as a factory for rowsets
  can use this capability to create a rowset containing data from
  non-SQL data sources. Nevertheless, it is expected that most of the time,
  <code>CachedRowSet</code> objects will contain data that was fetched
  from an SQL database using the JDBC API.
  <h3>9.0 Setting Properties</h3>
  All rowsets maintain a set of properties, which will usually be set using
  a tool.  The number and kinds of properties a rowset has will vary,
  depending on what the rowset does and how it gets its data.  For example,
  rowsets that get their data from a <code>ResultSet</code> object need to
  set the properties that are required for making a database connection.
  If a rowset uses the <code>DriverManager</code> facility to make a
  connection, it needs to set a property for the JDBC URL that identifies
  the appropriate driver, and it needs to set the properties that give the
  user name and password.
  If, on the other hand, the rowset uses a <code>DataSource</code> object
  to make the connection, which is the preferred method, it does not need to
  set the property for the JDBC URL.  Instead, it needs to set
  properties for the logical name of the data source, for the user name,
  and for the password.
  <p>
  NOTE:  In order to use a <code>DataSource</code> object for making a
  connection, the <code>DataSource</code> object must have been registered
  with a naming service that uses the Java Naming and Directory
  Interface™ (JNDI) API.  This registration
  is usually done by a person acting in the capacity of a system
  administrator.
  </p><p>
  In order to be able to populate itself with data from a database, a rowset
  needs to set a command property.  This property is a query that is a
  <code>PreparedStatement</code> object, which allows the query to have
  parameter placeholders that are set at run time, as opposed to design time.
  To set these placeholder parameters with values, a rowset provides
  setter methods for setting values of each data type,
  similar to the setter methods provided by the <code>PreparedStatement</code>
  interface.
  </p><p>
  The following code fragment illustrates how the <code>CachedRowSet</code>
  object <code>crs</code> might have its command property set.  Note that if a
  tool is used to set properties, this is the code that the tool would use.
  </p><pre>{@code
     crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS " +
                    "WHERE CREDIT_LIMIT &gt; ? AND REGION = ?");
  } </pre>
  <p>
  The values that will be used to set the command's placeholder parameters are
  contained in the <code>RowSet</code> object's <code>params</code> field, which is a
  <code>Vector</code> object.
  The <code>CachedRowSet</code> class provides a set of setter
  methods for setting the elements in its <code>params</code> field.  The
  following code fragment demonstrates setting the two parameters in the
  query from the previous example.
  </p><pre>     crs.setInt(1, 5000);
     crs.setString(2, "West");
  </pre>
  <p>
  The <code>params</code> field now contains two elements, each of which is
  an array two elements long.  The first element is the parameter number;
  the second is the value to be set.
  In this case, the first element of <code>params</code> is
  <code>1</code>, <code>5000</code>, and the second element is <code>2</code>,
  <code>"West"</code>.  When an application calls the method
  <code>execute</code>, it will in turn call on this <code>RowSet</code> object's reader,
  which will in turn invoke its <code>readData</code> method. As part of
  its implementation, <code>readData</code> will get the values in
  <code>params</code> and use them to set the command's placeholder
  parameters.
  The following code fragment gives an idea of how the reader
  does this, after obtaining the <code>Connection</code> object
  <code>con</code>.
  </p><pre>{@code
     PreparedStatement pstmt = con.prepareStatement(crs.getCommand());
     reader.decodeParams();
     // decodeParams figures out which setter methods to use and does something
     // like the following:
     //    for (i = 0; i &lt; params.length; i++) {
     //        pstmt.setObject(i + 1, params[i]);
     //    }
  }</pre>
  <p>
  At this point, the command for <code>crs</code> is the query {@code "SELECT
  FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &gt; 5000
  AND REGION = "West"}.  After the <code>readData</code> method executes
  this command with the following line of code, it will have the data from
  <code>rs</code> with which to populate <code>crs</code>.
  </p><pre>{@code
      ResultSet rs = pstmt.executeQuery();
  }</pre>
  <p>
  The preceding code fragments give an idea of what goes on behind the
  scenes; they would not appear in an application, which would not invoke
  methods like <code>readData</code> and <code>decodeParams</code>.
  In contrast, the following code fragment shows what an application might do.
  It sets the rowset's command, sets the command's parameters, and executes
  the command. Simply by calling the <code>execute</code> method,
  <code>crs</code> populates itself with the requested data from the
  table <code>CUSTOMERS</code>.
  </p><pre>{@code
     crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS" +
                    "WHERE CREDIT_LIMIT &gt; ? AND REGION = ?");
     crs.setInt(1, 5000);
     crs.setString(2, "West");
     crs.execute();
  }</pre>
  <h3>10.0 Paging Data</h3>
  Because a <code>CachedRowSet</code> object stores data in memory,
  the amount of data that it can contain at any one
  time is determined by the amount of memory available. To get around this limitation,
  a <code>CachedRowSet</code> object can retrieve data from a <code>ResultSet</code>
  object in chunks of data, called <i>pages</i>. To take advantage of this mechanism,
  an application sets the number of rows to be included in a page using the method
  <code>setPageSize</code>. In other words, if the page size is set to five, a chunk
  of five rows of
  data will be fetched from the data source at one time. An application can also
  optionally set the maximum number of rows that may be fetched at one time.  If the
  maximum number of rows is set to zero, or no maximum number of rows is set, there is
  no limit to the number of rows that may be fetched at a time.
  <p>
  After properties have been set,
  the <code>CachedRowSet</code> object must be populated with data
  using either the method <code>populate</code> or the method <code>execute</code>.
  The following lines of code demonstrate using the method <code>populate</code>.
  Note that this version of the method takes two parameters, a <code>ResultSet</code>
  handle and the row in the <code>ResultSet</code> object from which to start
  retrieving rows.
  </p><pre>      CachedRowSet crs = new CachedRowSetImpl();
      crs.setMaxRows(20);
      crs.setPageSize(4);
      crs.populate(rsHandle, 10);
  </pre>
  When this code runs, <i>crs</i> will be populated with four rows from
  <i>rsHandle</i> starting with the tenth row.
  <p>
  The next code fragment shows populating a <code>CachedRowSet</code> object using the
  method <code>execute</code>, which may or may not take a <code>Connection</code>
  object as a parameter.  This code passes <code>execute</code> the <code>Connection</code>
  object <i>conHandle</i>.
  </p><p>
  Note that there are two differences between the following code
  fragment and the previous one. First, the method <code>setMaxRows</code> is not
  called, so there is no limit set for the number of rows that <i>crs</i> may contain.
  (Remember that <i>crs</i> always has the overriding limit of how much data it can
  store in memory.) The second difference is that the you cannot pass the method
  <code>execute</code> the number of the row in the <code>ResultSet</code> object
  from which to start retrieving rows. This method always starts with the first row.
  </p><pre>      CachedRowSet crs = new CachedRowSetImpl();
      crs.setPageSize(5);
      crs.execute(conHandle);
  </pre>
  After this code has run, <i>crs</i> will contain five rows of data from the
  <code>ResultSet</code> object produced by the command for <i>crs</i>. The writer
  for <i>crs</i> will use <i>conHandle</i> to connect to the data source and
  execute the command for <i>crs</i>. An application is then able to operate on the
  data in <i>crs</i> in the same way that it would operate on data in any other
  <code>CachedRowSet</code> object.
  <p>
  To access the next page (chunk of data), an application calls the method
  <code>nextPage</code>.  This method creates a new <code>CachedRowSet</code> object
  and fills it with the next page of data.  For example, assume that the
  <code>CachedRowSet</code> object's command returns a <code>ResultSet</code> object
  <i>rs</i> with 1000 rows of data.  If the page size has been set to 100, the first
   call to the method <code>nextPage</code> will create a <code>CachedRowSet</code> object
  containing the first 100 rows of <i>rs</i>. After doing what it needs to do with the
  data in these first 100 rows, the application can again call the method
  <code>nextPage</code> to create another <code>CachedRowSet</code> object
  with the second 100 rows from <i>rs</i>. The data from the first <code>CachedRowSet</code>
  object will no longer be in memory because it is replaced with the data from the
  second <code>CachedRowSet</code> object. After the tenth call to the method <code>nextPage</code>,
  the tenth <code>CachedRowSet</code> object will contain the last 100 rows of data from
  <i>rs</i>, which are stored in memory. At any given time, the data from only one
  <code>CachedRowSet</code> object is stored in memory.
  </p><p>
  The method <code>nextPage</code> returns <code>true</code> as long as the current
  page is not the last page of rows and <code>false</code> when there are no more pages.
  It can therefore be used in a <code>while</code> loop to retrieve all of the pages,
  as is demonstrated in the following lines of code.
  </p><pre>      CachedRowSet crs = CachedRowSetImpl();
      crs.setPageSize(100);
      crs.execute(conHandle);
      while(crs.nextPage()) {
          while(crs.next()) {
              . . . // operate on chunks (of 100 rows each) in crs,
                    // row by row
          }
      }
  </pre>
  After this code fragment has been run, the application will have traversed all
  1000 rows, but it will have had no more than 100 rows in memory at a time.
  <p>
  The <code>CachedRowSet</code> interface also defines the method <code>previousPage</code>.
  Just as the method <code>nextPage</code> is analogous to the <code>ResultSet</code>
  method <code>next</code>, the method <code>previousPage</code> is analogous to
  the <code>ResultSet</code> method <code>previous</code>.  Similar to the method
  <code>nextPage</code>, <code>previousPage</code> creates a <code>CachedRowSet</code>
  object containing the number of rows set as the page size.  So, for instance, the
  method <code>previousPage</code> could be used in a <code>while</code> loop at
  the end of the preceding code fragment to navigate back through the pages from the last
  page to the first page.
  The method <code>previousPage</code> is also similar to <code>nextPage</code>
  in that it can be used in a <code>while</code>
  loop, except that it returns <code>true</code> as long as there is another page
  preceding it and <code>false</code> when there are no more pages ahead of it.
  </p><p>
  By positioning the cursor after the last row for each page,
  as is done in the following code fragment, the method <code>previous</code>
  navigates from the last row to the first row in each page.
  The code could also have left the cursor before the first row on each page and then
  used the method <code>next</code> in a <code>while</code> loop to navigate each page
  from the first row to the last row.
  </p><p>
  The following code fragment assumes a continuation from the previous code fragment,
  meaning that the cursor for the tenth <code>CachedRowSet</code> object is on the
  last row.  The code moves the cursor to after the last row so that the first
  call to the method <code>previous</code> will put the cursor back on the last row.
  After going through all of the rows in the last page (the <code>CachedRowSet</code>
  object <i>crs</i>), the code then enters
  the <code>while</code> loop to get to the ninth page, go through the rows backwards,
  go to the eighth page, go through the rows backwards, and so on to the first row
  of the first page.
  </p><pre>      crs.afterLast();
      while(crs.previous())  {
          . . . // navigate through the rows, last to first
      {
      while(crs.previousPage())  {
          crs.afterLast();
          while(crs.previous())  {
              . . . // go from the last row to the first row of each page
          }
      }
  </pre>
  @author Jonathan Bruce</div>
<a id="L630" name="L630"></a> 630 
<a id="L631" name="L631"></a> 631 <strong class="reserved">public</strong> <strong class="reserved">interface</strong> <a href="../R/1135.html" title="Multiple referred from 6 places.">CachedRowSet</a> <strong class="reserved">extends</strong> <a href="../S/4481.html#L87" title="Defined at 87 in src/javax/sql/RowSet.java.">RowSet</a>, <a href="../S/4465.html#L133" title="Defined at 133 in src/javax/sql/rowset/Joinable.java.">Joinable</a> <em class="brace">{</em>
<a id="L632" name="L632"></a> 632 
<div class="comment">
     Populates this <code>CachedRowSet</code> object with data from
     the given <code>ResultSet</code> object.
     <p>
     This method can be used as an alternative to the <code>execute</code> method when an
     application has a connection to an open <code>ResultSet</code> object.
     Using the method <code>populate</code> can be more efficient than using
     the version of the <code>execute</code> method that takes no parameters
     because it does not open a new connection and re-execute this
     <code>CachedRowSet</code> object's command. Using the <code>populate</code>
     method is more a matter of convenience when compared to using the version
     of <code>execute</code> that takes a <code>ResultSet</code> object.
     @param data the <code>ResultSet</code> object containing the data
     to be read into this <code>CachedRowSet</code> object
     @throws SQLException if a null <code>ResultSet</code> object is supplied
     or this <code>CachedRowSet</code> object cannot
     retrieve the associated <code>ResultSetMetaData</code> object
     @see #execute
     @see java.sql.ResultSet
     @see java.sql.ResultSetMetaData</p></div>
<a id="L655" name="L655"></a> 655     <strong class="reserved">public</strong> <strong class="reserved">void</strong> populate(<a href="../S/2602.html#L148" title="Defined at 148 in src/java/sql/ResultSet.java.">ResultSet</a> <a href="../S/6040.html#L177" title="Defined at 177 in src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java.">data</a>) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L656" name="L656"></a> 656 
<div class="comment">
     Populates this <code>CachedRowSet</code> object with data, using the
     given connection to produce the result set from which the data will be read.
     This method should close any database connections that it creates to
     ensure that this <code>CachedRowSet</code> object is disconnected except when
     it is reading data from its data source or writing data to its data source.
     <p>
     The reader for this <code>CachedRowSet</code> object
     will use <i>conn</i> to establish a connection to the data source
     so that it can execute the rowset's command and read data from the
     the resulting <code>ResultSet</code> object into this
     <code>CachedRowSet</code> object. This method also closes <i>conn</i>
     after it has populated this <code>CachedRowSet</code> object.
     </p><p>
     If this method is called when an implementation has already been
     populated, the contents and the metadata are (re)set. Also, if this method is
     called before the method <code>acceptChanges</code> has been called
     to commit outstanding updates, those updates are lost.
     @param conn a standard JDBC <code>Connection</code> object with valid
     properties
     @throws SQLException if an invalid <code>Connection</code> object is supplied
     or an error occurs in establishing the connection to the
     data source
     @see #populate
     @see java.sql.Connection</p></div>
<a id="L684" name="L684"></a> 684     <strong class="reserved">public</strong> <strong class="reserved">void</strong> <a href="../R/14093.html" title="Multiple referred from 117 places.">execute</a>(<a href="../D/1801.html" title="Multiple defined in 3 places.">Connection</a> conn) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L685" name="L685"></a> 685 
<div class="comment">
     Propagates row update, insert and delete changes made to this
     <code>CachedRowSet</code> object to the underlying data source.
     <p>
     This method calls on this <code>CachedRowSet</code> object's writer
     to do the work behind the scenes.
     Standard <code>CachedRowSet</code> implementations should use the
     <code>SyncFactory</code> singleton
     to obtain a <code>SyncProvider</code> instance providing a
     <code>RowSetWriter</code> object (writer).  The writer will attempt
     to propagate changes made in this <code>CachedRowSet</code> object
     back to the data source.
     </p><p>
     When the method <code>acceptChanges</code> executes successfully, in
     addition to writing changes to the data source, it
     makes the values in the current row be the values in the original row.
     </p><p>
     Depending on the synchronization level of the <code>SyncProvider</code>
     implementation being used, the writer will compare the original values
     with those in the data source to check for conflicts. When there is a conflict,
     the <code>RIOptimisticProvider</code> implementation, for example, throws a
     <code>SyncProviderException</code> and does not write anything to the
     data source.
     </p><p>
     An application may choose to catch the <code>SyncProviderException</code>
     object and retrieve the <code>SyncResolver</code> object it contains.
     The <code>SyncResolver</code> object lists the conflicts row by row and
     sets a lock on the data source to avoid further conflicts while the
     current conflicts are being resolved.
     Further, for each conflict, it provides methods for examining the conflict
     and setting the value that should be persisted in the data source.
     After all conflicts have been resolved, an application must call the
     <code>acceptChanges</code> method again to write resolved values to the
     data source.  If all of the values in the data source are already the
     values to be persisted, the method <code>acceptChanges</code> does nothing.
     </p><p>
     Some provider implementations may use locks to ensure that there are no
     conflicts.  In such cases, it is guaranteed that the writer will succeed in
     writing changes to the data source when the method <code>acceptChanges</code>
     is called.  This method may be called immediately after the methods
     <code>updateRow</code>, <code>insertRow</code>, or <code>deleteRow</code>
     have been called, but it is more efficient to call it only once after
     all changes have been made so that only one connection needs to be
     established.
     </p><p>
     Note: The <code>acceptChanges()</code> method will determine if the
     <code>COMMIT_ON_ACCEPT_CHANGES</code> is set to true or not. If it is set
     to true, all updates in the synchronization are committed to the data
     source. Otherwise, the application <b>must</b> explicity call the
     <code>commit()</code> or <code>rollback()</code> methods as appropriate.
     @throws SyncProviderException if the underlying
     synchronization provider's writer fails to write the updates
     back to the data source
     @see #acceptChanges(java.sql.Connection)
     @see javax.sql.RowSetWriter
     @see javax.sql.rowset.spi.SyncFactory
     @see javax.sql.rowset.spi.SyncProvider
     @see javax.sql.rowset.spi.SyncProviderException
     @see javax.sql.rowset.spi.SyncResolver</p></div>
<a id="L747" name="L747"></a> 747     <strong class="reserved">public</strong> <strong class="reserved">void</strong> acceptChanges() <strong class="reserved">throws</strong> <a href="../S/4456.html#L65" title="Defined at 65 in src/javax/sql/rowset/spi/SyncProviderException.java.">SyncProviderException</a>;
<a id="L748" name="L748"></a> 748 
<div class="comment">
     Propagates all row update, insert and delete changes to the
     data source backing this <code>CachedRowSet</code> object
     using the specified <code>Connection</code> object to establish a
     connection to the data source.
     <p>
     The other version of the <code>acceptChanges</code> method is not passed
     a connection because it uses
     the <code>Connection</code> object already defined within the <code>RowSet</code>
     object, which is the connection used for populating it initially.
     </p><p>
     This form of the method <code>acceptChanges</code> is similar to the
     form that takes no arguments; however, unlike the other form, this form
     can be used only when the underlying data source is a JDBC data source.
     The updated <code>Connection</code> properties must be used by the
     <code>SyncProvider</code> to reset the <code>RowSetWriter</code>
     configuration to ensure that the contents of the <code>CachedRowSet</code>
     object are synchronized correctly.
     </p><p>
     When the method <code>acceptChanges</code> executes successfully, in
     addition to writing changes to the data source, it
     makes the values in the current row be the values in the original row.
     </p><p>
     Depending on the synchronization level of the <code>SyncProvider</code>
     implementation being used, the writer will compare the original values
     with those in the data source to check for conflicts. When there is a conflict,
     the <code>RIOptimisticProvider</code> implementation, for example, throws a
     <code>SyncProviderException</code> and does not write anything to the
     data source.
     </p><p>
     An application may choose to catch the <code>SyncProviderException</code>
     object and retrieve the <code>SyncResolver</code> object it contains.
     The <code>SyncResolver</code> object lists the conflicts row by row and
     sets a lock on the data source to avoid further conflicts while the
     current conflicts are being resolved.
     Further, for each conflict, it provides methods for examining the conflict
     and setting the value that should be persisted in the data source.
     After all conflicts have been resolved, an application must call the
     <code>acceptChanges</code> method again to write resolved values to the
     data source.  If all of the values in the data source are already the
     values to be persisted, the method <code>acceptChanges</code> does nothing.
     </p><p>
     Some provider implementations may use locks to ensure that there are no
     conflicts.  In such cases, it is guaranteed that the writer will succeed in
     writing changes to the data source when the method <code>acceptChanges</code>
     is called.  This method may be called immediately after the methods
     <code>updateRow</code>, <code>insertRow</code>, or <code>deleteRow</code>
     have been called, but it is more efficient to call it only once after
     all changes have been made so that only one connection needs to be
     established.
     </p><p>
     Note: The <code>acceptChanges()</code> method will determine if the
     <code>COMMIT_ON_ACCEPT_CHANGES</code> is set to true or not. If it is set
     to true, all updates in the synchronization are committed to the data
     source. Otherwise, the application <b>must</b> explicity call the
     <code>commit</code> or <code>rollback</code> methods as appropriate.
     @param con a standard JDBC <code>Connection</code> object
     @throws SyncProviderException if the underlying
     synchronization provider's writer fails to write the updates
     back to the data source
     @see #acceptChanges()
     @see javax.sql.RowSetWriter
     @see javax.sql.rowset.spi.SyncFactory
     @see javax.sql.rowset.spi.SyncProvider
     @see javax.sql.rowset.spi.SyncProviderException
     @see javax.sql.rowset.spi.SyncResolver</p></div>
<a id="L817" name="L817"></a> 817     <strong class="reserved">public</strong> <strong class="reserved">void</strong> acceptChanges(<a href="../D/1801.html" title="Multiple defined in 3 places.">Connection</a> con) <strong class="reserved">throws</strong> <a href="../S/4456.html#L65" title="Defined at 65 in src/javax/sql/rowset/spi/SyncProviderException.java.">SyncProviderException</a>;
<a id="L818" name="L818"></a> 818 
<div class="comment">
     Restores this <code>CachedRowSet</code> object to its original
     value, that is, its value before the last set of changes. If there
     have been no changes to the rowset or only one set of changes,
     the original value is the value with which this <code>CachedRowSet</code> object
     was populated; otherwise, the original value is
     the value it had immediately before its current value.
     <p>
     When this method is called, a <code>CachedRowSet</code> implementation
     must ensure that all updates, inserts, and deletes to the current
     rowset instance are replaced by the previous values. In addition,
     the cursor should be
     reset to the first row and a <code>rowSetChanged</code> event
     should be fired to notify all registered listeners.
     @throws SQLException if an error occurs rolling back the current value of
           this <code>CachedRowSet</code> object to its previous value
     @see javax.sql.RowSetListener#rowSetChanged</p></div>
<a id="L838" name="L838"></a> 838     <strong class="reserved">public</strong> <strong class="reserved">void</strong> restoreOriginal() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L839" name="L839"></a> 839 
<div class="comment">
     Releases the current contents of this <code>CachedRowSet</code>
     object and sends a <code>rowSetChanged</code> event to all
     registered listeners. Any outstanding updates are discarded and
     the rowset contains no rows after this method is called. There
     are no interactions with the underlying data source, and any rowset
     content, metadata, and content updates should be non-recoverable.
     <p>
     This <code>CachedRowSet</code> object should lock until its contents and
     associated updates are fully cleared, thus preventing 'dirty' reads by
     other components that hold a reference to this <code>RowSet</code> object.
     In addition, the contents cannot be released
     until all all components reading this <code>CachedRowSet</code> object
     have completed their reads. This <code>CachedRowSet</code> object
     should be returned to normal behavior after firing the
     <code>rowSetChanged</code> event.
     </p><p>
     The metadata, including JDBC properties and Synchronization SPI
     properties, are maintained for future use. It is important that
     properties such as the <code>command</code> property be
     relevant to the originating data source from which this <code>CachedRowSet</code>
     object was originally established.
     </p><p>
     This method empties a rowset, as opposed to the <code>close</code> method,
     which marks the entire rowset as recoverable to allow the garbage collector
     the rowset's Java VM resources.
     @throws SQLException if an error occurs flushing the contents of this
     <code>CachedRowSet</code> object
     @see javax.sql.RowSetListener#rowSetChanged
     @see java.sql.ResultSet#close</p></div>
<a id="L872" name="L872"></a> 872     <strong class="reserved">public</strong> <strong class="reserved">void</strong> <a href="../R/25846.html" title="Multiple referred from 40 places.">release</a>() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L873" name="L873"></a> 873 
<div class="comment">
     Cancels the deletion of the current row and notifies listeners that
     a row has changed. After this method is called, the current row is
     no longer marked for deletion. This method can be called at any
     time during the lifetime of the rowset.
     <p>
     In addition, multiple cancellations of row deletions can be made
     by adjusting the position of the cursor using any of the cursor
     position control methods such as:
     </p><ul><li><code>CachedRowSet.absolute</code>
     </li><li><code>CachedRowSet.first</code>
     </li><li><code>CachedRowSet.last</code>
     </li></ul>
     @throws SQLException if (1) the current row has not been deleted or
     (2) the cursor is on the insert row, before the first row, or
     after the last row
     @see javax.sql.rowset.CachedRowSet#undoInsert
     @see java.sql.ResultSet#cancelRowUpdates</div>
<a id="L895" name="L895"></a> 895     <strong class="reserved">public</strong> <strong class="reserved">void</strong> undoDelete() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L896" name="L896"></a> 896 
<div class="comment">
     Immediately removes the current row from this <code>CachedRowSet</code>
     object if the row has been inserted, and also notifies listeners that a
     row has changed. This method can be called at any time during the
     lifetime of a rowset and assuming the current row is within
     the exception limitations (see below), it cancels the row insertion
     of the current row.
     <p>
     In addition, multiple cancellations of row insertions can be made
     by adjusting the position of the cursor using any of the cursor
     position control methods such as:
     </p><ul><li><code>CachedRowSet.absolute</code>
     </li><li><code>CachedRowSet.first</code>
     </li><li><code>CachedRowSet.last</code>
     </li></ul>
     @throws SQLException if (1) the current row has not been inserted or (2)
     the cursor is before the first row, after the last row, or on the
     insert row
     @see javax.sql.rowset.CachedRowSet#undoDelete
     @see java.sql.ResultSet#cancelRowUpdates</div>
<a id="L920" name="L920"></a> 920     <strong class="reserved">public</strong> <strong class="reserved">void</strong> undoInsert() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L921" name="L921"></a> 921 
<a id="L922" name="L922"></a> 922 
<div class="comment">
     Immediately reverses the last update operation if the
     row has been modified. This method can be
     called to reverse updates on all columns until all updates in a row have
     been rolled back to their state just prior to the last synchronization
     (<code>acceptChanges</code>) or population. This method may also be called
     while performing updates to the insert row.
     <p>
     <code>undoUpdate</code> may be called at any time during the lifetime of a
     rowset; however, after a synchronization has occurred, this method has no
     effect until further modification to the rowset data has occurred.
     @throws SQLException if the cursor is before the first row or after the last
         row in in this <code>CachedRowSet</code> object
     @see #undoDelete
     @see #undoInsert
     @see java.sql.ResultSet#cancelRowUpdates</p></div>
<a id="L941" name="L941"></a> 941     <strong class="reserved">public</strong> <strong class="reserved">void</strong> undoUpdate() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L942" name="L942"></a> 942 
<div class="comment">
     Indicates whether the designated column in the current row of this
     <code>CachedRowSet</code> object has been updated.
     @param idx an <code>int</code> identifying the column to be checked for updates
     @return <code>true</code> if the designated column has been visibly updated;
     <code>false</code> otherwise
     @throws SQLException if the cursor is on the insert row, before the first row,
         or after the last row
     @see java.sql.DatabaseMetaData#updatesAreDetected</div>
<a id="L954" name="L954"></a> 954     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> columnUpdated(<strong class="reserved">int</strong> idx) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L955" name="L955"></a> 955 
<a id="L956" name="L956"></a> 956 
<div class="comment">
     Indicates whether the designated column in the current row of this
     <code>CachedRowSet</code> object has been updated.
     @param columnName a <code>String</code> object giving the name of the
            column to be checked for updates
     @return <code>true</code> if the column has been visibly updated;
     <code>false</code> otherwise
     @throws SQLException if the cursor is on the insert row, before the first row,
          or after the last row
     @see java.sql.DatabaseMetaData#updatesAreDetected</div>
<a id="L969" name="L969"></a> 969     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> columnUpdated(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> columnName) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L970" name="L970"></a> 970 
<div class="comment">
     Converts this <code>CachedRowSet</code> object to a <code>Collection</code>
     object that contains all of this <code>CachedRowSet</code> object's data.
     Implementations have some latitude in
     how they can represent this <code>Collection</code> object because of the
     abstract nature of the <code>Collection</code> framework.
     Each row must be fully represented in either a
     general purpose <code>Collection</code> implementation or a specialized
     <code>Collection</code> implementation, such as a <code>TreeMap</code>
     object or a <code>Vector</code> object.
     An SQL <code>NULL</code> column value must be represented as a <code>null</code>
     in the Java programming language.
     <p>
     The standard reference implementation for the <code>CachedRowSet</code>
     interface uses a <code>TreeMap</code> object for the rowset, with the
     values in each row being contained in  <code>Vector</code> objects. It is
     expected that most implementations will do the same.
     </p><p>
     The <code>TreeMap</code> type of collection guarantees that the map will be in
     ascending key order, sorted according to the natural order for the
     key's class.
     Each key references a <code>Vector</code> object that corresponds to one
     row of a <code>RowSet</code> object. Therefore, the size of each
     <code>Vector</code> object  must be exactly equal to the number of
     columns in the <code>RowSet</code> object.
     The key used by the <code>TreeMap</code> collection is determined by the
     implementation, which may choose to leverage a set key that is
     available within the internal <code>RowSet</code> tabular structure by
     virtue of a key already set either on the <code>RowSet</code> object
     itself or on the underlying SQL data.
     </p><p>
     @return a <code>Collection</code> object that contains the values in
     each row in this <code>CachedRowSet</code> object
     @throws SQLException if an error occurs generating the collection
     @see #toCollection(int)
     @see #toCollection(String)</p></div>
<a id="L1009" name="L1009"></a>1009     <strong class="reserved">public</strong> <a href="../S/875.html#L144" title="Defined at 144 in src/java/util/Collection.java.">Collection</a>&lt;?&gt; toCollection() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1010" name="L1010"></a>1010 
<div class="comment">
     Converts the designated column in this <code>CachedRowSet</code> object
     to a <code>Collection</code> object. Implementations have some latitude in
     how they can represent this <code>Collection</code> object because of the
     abstract nature of the <code>Collection</code> framework.
     Each column value should be fully represented in either a
     general purpose <code>Collection</code> implementation or a specialized
     <code>Collection</code> implementation, such as a <code>Vector</code> object.
     An SQL <code>NULL</code> column value must be represented as a <code>null</code>
     in the Java programming language.
     <p>
     The standard reference implementation uses a <code>Vector</code> object
     to contain the column values, and it is expected
     that most implementations will do the same. If a <code>Vector</code> object
     is used, it size must be exactly equal to the number of rows
     in this <code>CachedRowSet</code> object.
     @param column an <code>int</code> indicating the column whose values
            are to be represented in a <code>Collection</code> object
     @return a <code>Collection</code> object that contains the values
     stored in the specified column of this <code>CachedRowSet</code>
     object
     @throws SQLException if an error occurs generating the collection or
     an invalid column id is provided
     @see #toCollection
     @see #toCollection(String)</p></div>
<a id="L1038" name="L1038"></a>1038     <strong class="reserved">public</strong> <a href="../S/875.html#L144" title="Defined at 144 in src/java/util/Collection.java.">Collection</a>&lt;?&gt; toCollection(<strong class="reserved">int</strong> <a href="../S/7696.html#L51" title="Defined at 51 in src/com/sun/javadoc/SourcePosition.java.">column</a>) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1039" name="L1039"></a>1039 
<div class="comment">
     Converts the designated column in this <code>CachedRowSet</code> object
     to a <code>Collection</code> object. Implementations have some latitude in
     how they can represent this <code>Collection</code> object because of the
     abstract nature of the <code>Collection</code> framework.
     Each column value should be fully represented in either a
     general purpose <code>Collection</code> implementation or a specialized
     <code>Collection</code> implementation, such as a <code>Vector</code> object.
     An SQL <code>NULL</code> column value must be represented as a <code>null</code>
     in the Java programming language.
     <p>
     The standard reference implementation uses a <code>Vector</code> object
     to contain the column values, and it is expected
     that most implementations will do the same. If a <code>Vector</code> object
     is used, it size must be exactly equal to the number of rows
     in this <code>CachedRowSet</code> object.
     @param column a <code>String</code> object giving the name of the
            column whose values are to be represented in a collection
     @return a <code>Collection</code> object that contains the values
     stored in the specified column of this <code>CachedRowSet</code>
     object
     @throws SQLException if an error occurs generating the collection or
     an invalid column id is provided
     @see #toCollection
     @see #toCollection(int)</p></div>
<a id="L1067" name="L1067"></a>1067     <strong class="reserved">public</strong> <a href="../S/875.html#L144" title="Defined at 144 in src/java/util/Collection.java.">Collection</a>&lt;?&gt; toCollection(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../S/7696.html#L51" title="Defined at 51 in src/com/sun/javadoc/SourcePosition.java.">column</a>) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1068" name="L1068"></a>1068 
<div class="comment">
     Retrieves the <code>SyncProvider</code> implementation for this
     <code>CachedRowSet</code> object. Internally, this method is used by a rowset
     to trigger read or write actions between the rowset
     and the data source. For example, a rowset may need to get a handle
     on the the rowset reader (<code>RowSetReader</code> object) from the
     <code>SyncProvider</code> to allow the rowset to be populated.
     <pre>         RowSetReader rowsetReader = null;
         SyncProvider provider =
             SyncFactory.getInstance("javax.sql.rowset.provider.RIOptimisticProvider");
             if (provider instanceof RIOptimisticProvider) {
                 rowsetReader = provider.getRowSetReader();
             }
     </pre>
     Assuming <i>rowsetReader</i> is a private, accessible field within
     the rowset implementation, when an application calls the <code>execute</code>
     method, it in turn calls on the reader's <code>readData</code> method
     to populate the <code>RowSet</code> object.
    <pre>         rowsetReader.readData((RowSetInternal)this);
     </pre>
     <p>
     In addition, an application can use the <code>SyncProvider</code> object
     returned by this method to call methods that return information about the
     <code>SyncProvider</code> object, including information about the
     vendor, version, provider identification, synchronization grade, and locks
     it currently has set.
     @return the <code>SyncProvider</code> object that was set when the rowset
          was instantiated, or if none was was set, the default provider
     @throws SQLException if an error occurs while returning the
     <code>SyncProvider</code> object
     @see #setSyncProvider</p></div>
<a id="L1104" name="L1104"></a>1104     <strong class="reserved">public</strong> <a href="../S/4457.html#L213" title="Defined at 213 in src/javax/sql/rowset/spi/SyncProvider.java.">SyncProvider</a> getSyncProvider() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1105" name="L1105"></a>1105 
<div class="comment">
     Sets the <code>SyncProvider</code> object for this <code>CachedRowSet</code>
     object to the one specified.  This method
     allows the <code>SyncProvider</code> object to be reset.
     <p>
     A <code>CachedRowSet</code> implementation should always be instantiated
     with an available <code>SyncProvider</code> mechanism, but there are
     cases where resetting the <code>SyncProvider</code> object is desirable
     or necessary. For example, an application might want to use the default
     <code>SyncProvider</code> object for a time and then choose to use a provider
     that has more recently become available and better fits its needs.
     </p><p>
     Resetting the <code>SyncProvider</code> object causes the
     <code>RowSet</code> object to request a new <code>SyncProvider</code> implementation
     from the <code>SyncFactory</code>. This has the effect of resetting
     all previous connections and relationships with the originating
     data source and can potentially drastically change the synchronization
     behavior of a disconnected rowset.
     @param provider a <code>String</code> object giving the fully qualified class
            name of a <code>SyncProvider</code> implementation
     @throws SQLException if an error occurs while attempting to reset the
     <code>SyncProvider</code> implementation
     @see #getSyncProvider</p></div>
<a id="L1131" name="L1131"></a>1131     <strong class="reserved">public</strong> <strong class="reserved">void</strong> setSyncProvider(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../D/29909.html" title="Multiple defined in 12 places.">provider</a>) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1132" name="L1132"></a>1132 
<div class="comment">
     Returns the number of rows in this <code>CachedRowSet</code>
     object.
     @return number of rows in the rowset</div>
<a id="L1139" name="L1139"></a>1139     <strong class="reserved">public</strong> <strong class="reserved">int</strong> <a href="../R/28639.html" title="Multiple referred from 5617 places.">size</a>();
<a id="L1140" name="L1140"></a>1140 
<div class="comment">
     Sets the metadata for this <code>CachedRowSet</code> object with
     the given <code>RowSetMetaData</code> object. When a
     <code>RowSetReader</code> object is reading the contents of a rowset,
     it creates a <code>RowSetMetaData</code> object and initializes
     it using the methods in the <code>RowSetMetaData</code> implementation.
     The reference implementation uses the <code>RowSetMetaDataImpl</code>
     class. When the reader has completed reading the rowset contents,
     this method is called internally to pass the <code>RowSetMetaData</code>
     object to the rowset.
     @param md a <code>RowSetMetaData</code> object containing
     metadata about the columns in this <code>CachedRowSet</code> object
     @throws SQLException if invalid metadata is supplied to the
     rowset</div>
<a id="L1157" name="L1157"></a>1157     <strong class="reserved">public</strong> <strong class="reserved">void</strong> setMetaData(<a href="../S/4479.html#L47" title="Defined at 47 in src/javax/sql/RowSetMetaData.java.">RowSetMetaData</a> md) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1158" name="L1158"></a>1158 
<div class="comment">
     Returns a <code>ResultSet</code> object containing the original value of this
     <code>CachedRowSet</code> object.
     <p>
     The cursor for the <code>ResultSet</code>
     object should be positioned before the first row.
     In addition, the returned <code>ResultSet</code> object should have the following
     properties:
     </p><ul>
     <li>ResultSet.TYPE_SCROLL_INSENSITIVE
     </li><li>ResultSet.CONCUR_UPDATABLE
     </li></ul>
     <p>
     The original value for a <code>RowSet</code> object is the value it had before
     the last synchronization with the underlying data source.  If there have been
     no synchronizations, the original value will be the value with which the
     <code>RowSet</code> object was populated.  This method is called internally
     when an application calls the method <code>acceptChanges</code> and the
     <code>SyncProvider</code> object has been implemented to check for conflicts.
     If this is the case, the writer compares the original value with the value
     currently in the data source to check for conflicts.
     @return a <code>ResultSet</code> object that contains the original value for
             this <code>CachedRowSet</code> object
     @throws SQLException if an error occurs producing the
     <code>ResultSet</code> object</p></div>
<a id="L1186" name="L1186"></a>1186    <strong class="reserved">public</strong> <a href="../S/2602.html#L148" title="Defined at 148 in src/java/sql/ResultSet.java.">ResultSet</a> getOriginal() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1187" name="L1187"></a>1187 
<div class="comment">
     Returns a <code>ResultSet</code> object containing the original value for the
     current row only of this <code>CachedRowSet</code> object.
     <p>
     The cursor for the <code>ResultSet</code>
     object should be positioned before the first row.
     In addition, the returned <code>ResultSet</code> object should have the following
     properties:
     </p><ul>
     <li>ResultSet.TYPE_SCROLL_INSENSITIVE
     </li><li>ResultSet.CONCUR_UPDATABLE
     </li></ul>
     @return the original result set of the row
     @throws SQLException if there is no current row
     @see #setOriginalRow</div>
<a id="L1205" name="L1205"></a>1205     <strong class="reserved">public</strong> <a href="../S/2602.html#L148" title="Defined at 148 in src/java/sql/ResultSet.java.">ResultSet</a> getOriginalRow() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1206" name="L1206"></a>1206 
<div class="comment">
     Sets the current row in this <code>CachedRowSet</code> object as the original
     row.
     <p>
     This method is called internally after the any modified values in the current
     row have been synchronized with the data source. The current row must be tagged
     as no longer inserted, deleted or updated.
     </p><p>
     A call to <code>setOriginalRow</code> is irreversible.
     @throws SQLException if there is no current row or an error is
     encountered resetting the contents of the original row
     @see #getOriginalRow</p></div>
<a id="L1221" name="L1221"></a>1221     <strong class="reserved">public</strong> <strong class="reserved">void</strong> setOriginalRow() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1222" name="L1222"></a>1222 
<div class="comment">
     Returns an identifier for the object (table) that was used to
     create this <code>CachedRowSet</code> object. This name may be set on multiple occasions,
     and the specification imposes no limits on how many times this
     may occur or whether standard implementations should keep track
     of previous table names.
     @return a <code>String</code> object giving the name of the table that is the
             source of data for this <code>CachedRowSet</code> object or <code>null</code>
             if no name has been set for the table
     @throws SQLException if an error is encountered returning the table name
     @see javax.sql.RowSetMetaData#getTableName</div>
<a id="L1236" name="L1236"></a>1236     <strong class="reserved">public</strong> <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> getTableName() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1237" name="L1237"></a>1237 
<div class="comment">
     Sets the identifier for the table from which this <code>CachedRowSet</code>
     object was derived to the given table name. The writer uses this name to
     determine which table to use when comparing the values in the data source with the
     <code>CachedRowSet</code> object's values during a synchronization attempt.
     The table identifier also indicates where modified values from this
     <code>CachedRowSet</code> object should be written.
     <p>
     The implementation of this <code>CachedRowSet</code> object may obtain the
     the name internally from the <code>RowSetMetaDataImpl</code> object.
     @param tabName a <code>String</code> object identifying the table from which this
             <code>CachedRowSet</code> object was derived; cannot be <code>null</code>
             but may be an empty string
     @throws SQLException if an error is encountered naming the table or
         <i>tabName</i> is <code>null</code>
     @see javax.sql.RowSetMetaData#setTableName
     @see javax.sql.RowSetWriter
     @see javax.sql.rowset.spi.SyncProvider</p></div>
<a id="L1258" name="L1258"></a>1258    <strong class="reserved">public</strong> <strong class="reserved">void</strong> setTableName(<a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> tabName) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1259" name="L1259"></a>1259 
<div class="comment">
     Returns an array containing one or more column numbers indicating the columns
     that form a key that uniquely
     identifies a row in this <code>CachedRowSet</code> object.
     @return an array containing the column number or numbers that indicate which columns
           constitute a primary key
           for a row in this <code>CachedRowSet</code> object. This array should be
           empty if no columns are representative of a primary key.
     @throws SQLException if this <code>CachedRowSet</code> object is empty
     @see #setKeyColumns
     @see Joinable#getMatchColumnIndexes
     @see Joinable#getMatchColumnNames</div>
<a id="L1274" name="L1274"></a>1274     <strong class="reserved">public</strong> <strong class="reserved">int</strong>[] getKeyColumns() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1275" name="L1275"></a>1275 
<div class="comment">
     Sets this <code>CachedRowSet</code> object's <code>keyCols</code>
     field with the given array of column numbers, which forms a key
     for uniquely identifying a row in this <code>CachedRowSet</code> object.
     <p>
     If a <code>CachedRowSet</code> object becomes part of a <code>JoinRowSet</code>
     object, the keys defined by this method and the resulting constraints are
     maintained if the columns designated as key columns also become match
     columns.
     @param keys an array of <code>int</code> indicating the columns that form
            a primary key for this <code>CachedRowSet</code> object; every
            element in the array must be greater than <code>0</code> and
            less than or equal to the number of columns in this rowset
     @throws SQLException if any of the numbers in the given array
                are not valid for this rowset
     @see #getKeyColumns
     @see Joinable#setMatchColumn(String)
     @see Joinable#setMatchColumn(int)</p></div>
<a id="L1297" name="L1297"></a>1297     <strong class="reserved">public</strong> <strong class="reserved">void</strong> setKeyColumns(<strong class="reserved">int</strong>[] <a href="../D/26726.html" title="Multiple defined in 22 places.">keys</a>) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1298" name="L1298"></a>1298 
<a id="L1299" name="L1299"></a>1299 
<div class="comment">
     Returns a new <code>RowSet</code> object backed by the same data as
     that of this <code>CachedRowSet</code> object. In effect, both
     <code>CachedRowSet</code> objects have a cursor over the same data.
     As a result, any changes made by a duplicate are visible to the original
     and to any other duplicates, just as a change made by the original is visible
     to all of its duplicates. If a duplicate calls a method that changes the
     underlying data, the method it calls notifies all registered listeners
     just as it would when it is called by the original <code>CachedRowSet</code>
     object.
     <p>
     In addition, any <code>RowSet</code> object
     created by this method will have the same properties as this
     <code>CachedRowSet</code> object. For example, if this <code>CachedRowSet</code>
     object is read-only, all of its duplicates will also be read-only. If it is
     changed to be updatable, the duplicates also become updatable.
     </p><p>
     NOTE: If multiple threads access <code>RowSet</code> objects created from
     the <code>createShared()</code> method, the following behavior is specified
     to preserve shared data integrity: reads and writes of all
     shared <code>RowSet</code> objects should be made serially between each
     object and the single underlying tabular structure.
     @return a new shared <code>RowSet</code> object that has the same properties
             as this <code>CachedRowSet</code> object and that has a cursor over
             the same data
     @throws SQLException if an error occurs or cloning is not
     supported in the underlying platform
     @see javax.sql.RowSetEvent
     @see javax.sql.RowSetListener</p></div>
<a id="L1331" name="L1331"></a>1331     <strong class="reserved">public</strong> <a href="../S/4481.html#L87" title="Defined at 87 in src/javax/sql/RowSet.java.">RowSet</a> createShared() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1332" name="L1332"></a>1332 
<div class="comment">
     Creates a <code>RowSet</code> object that is a deep copy of the data in
     this <code>CachedRowSet</code> object. In contrast to
     the <code>RowSet</code> object generated from a <code>createShared</code>
     call, updates made to the copy of the original <code>RowSet</code> object
     must not be visible to the original <code>RowSet</code> object. Also, any
     event listeners that are registered with the original
     <code>RowSet</code> must not have scope over the new
     <code>RowSet</code> copies. In addition, any constraint restrictions
     established must be maintained.
     @return a new <code>RowSet</code> object that is a deep copy
     of this <code>CachedRowSet</code> object and is
     completely independent of this <code>CachedRowSet</code> object
     @throws SQLException if an error occurs in generating the copy of
     the of this <code>CachedRowSet</code> object
     @see #createShared
     @see #createCopySchema
     @see #createCopyNoConstraints
     @see javax.sql.RowSetEvent
     @see javax.sql.RowSetListener</div>
<a id="L1355" name="L1355"></a>1355     <strong class="reserved">public</strong> <a href="../S/4448.html#L631" title="Defined at 631 in src/javax/sql/rowset/CachedRowSet.java.">CachedRowSet</a> createCopy() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1356" name="L1356"></a>1356 
<div class="comment">
      Creates a <code>CachedRowSet</code> object that is an empty copy of this
      <code>CachedRowSet</code> object.  The copy
      must not contain any contents but only represent the table
      structure of the original <code>CachedRowSet</code> object. In addition, primary
      or foreign key constraints set in the originating <code>CachedRowSet</code> object must
      be equally enforced in the new empty <code>CachedRowSet</code> object.
      In contrast to
      the <code>RowSet</code> object generated from a <code>createShared</code> method
      call, updates made to a copy of this <code>CachedRowSet</code> object with the
      <code>createCopySchema</code> method must not be visible to it.
      <p>
      Applications can form a <code>WebRowSet</code> object from the <code>CachedRowSet</code>
      object returned by this method in order
      to export the <code>RowSet</code> schema definition to XML for future use.
      @return An empty copy of this <code>CachedRowSet</code> object
      @throws SQLException if an error occurs in cloning the structure of this
              <code>CachedRowSet</code> object
      @see #createShared
      @see #createCopySchema
      @see #createCopyNoConstraints
      @see javax.sql.RowSetEvent
      @see javax.sql.RowSetListener</p></div>
<a id="L1381" name="L1381"></a>1381     <strong class="reserved">public</strong> <a href="../S/4448.html#L631" title="Defined at 631 in src/javax/sql/rowset/CachedRowSet.java.">CachedRowSet</a> createCopySchema() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1382" name="L1382"></a>1382 
<div class="comment">
      Creates a <code>CachedRowSet</code> object that is a deep copy of
      this <code>CachedRowSet</code> object's data but is independent of it.
      In contrast to
      the <code>RowSet</code> object generated from a <code>createShared</code>
      method call, updates made to a copy of this <code>CachedRowSet</code> object
      must not be visible to it. Also, any
      event listeners that are registered with this
      <code>CachedRowSet</code> object must not have scope over the new
      <code>RowSet</code> object. In addition, any constraint restrictions
      established for this <code>CachedRowSet</code> object must <b>not</b> be maintained
      in the copy.
      @return a new <code>CachedRowSet</code> object that is a deep copy
          of this <code>CachedRowSet</code> object and is
          completely independent of this  <code>CachedRowSet</code> object
      @throws SQLException if an error occurs in generating the copy of
          the of this <code>CachedRowSet</code> object
      @see #createCopy
      @see #createShared
      @see #createCopySchema
      @see javax.sql.RowSetEvent
      @see javax.sql.RowSetListener</div>
<a id="L1407" name="L1407"></a>1407     <strong class="reserved">public</strong> <a href="../S/4448.html#L631" title="Defined at 631 in src/javax/sql/rowset/CachedRowSet.java.">CachedRowSet</a> createCopyNoConstraints() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1408" name="L1408"></a>1408 
<div class="comment">
      Retrieves the first warning reported by calls on this <code>RowSet</code> object.
      Subsequent warnings on this <code>RowSet</code> object will be chained to the
      <code>RowSetWarning</code> object that this method returns.
      The warning chain is automatically cleared each time a new row is read.
      This method may not be called on a RowSet object that has been closed;
      doing so will cause a <code>SQLException</code> to be thrown.
      @return RowSetWarning the first <code>RowSetWarning</code>
      object reported or null if there are none
      @throws SQLException if this method is called on a closed RowSet
      @see RowSetWarning</div>
<a id="L1423" name="L1423"></a>1423     <strong class="reserved">public</strong> <a href="../S/4464.html#L56" title="Defined at 56 in src/javax/sql/rowset/RowSetWarning.java.">RowSetWarning</a> getRowSetWarnings() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1424" name="L1424"></a>1424 
<div class="comment">
      Retrieves a <code>boolean</code> indicating whether rows marked
      for deletion appear in the set of current rows. If <code>true</code> is
      returned, deleted rows are visible with the current rows. If
      <code>false</code> is returned, rows are not visible with the set of
      current rows. The default value is <code>false</code>.
      <p>
      Standard rowset implementations may choose to restrict this behavior
      due to security considerations or to better fit certain deployment
      scenarios. This is left as implementation defined and does not
      represent standard behavior.
      </p><p>
      Note: Allowing deleted rows to remain visible complicates the behavior
      of some standard JDBC <code>RowSet</code> Implementations methods.
      However, most rowset users can simply ignore this extra detail because
      only very specialized applications will likely want to take advantage of
      this feature.
      @return <code>true</code> if deleted rows are visible;
              <code>false</code> otherwise
      @throws SQLException if a rowset implementation is unable to
      to determine whether rows marked for deletion are visible
      @see #setShowDeleted</p></div>
<a id="L1449" name="L1449"></a>1449     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> getShowDeleted() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1450" name="L1450"></a>1450 
<div class="comment">
      Sets the property <code>showDeleted</code> to the given
      <code>boolean</code> value, which determines whether
      rows marked for deletion appear in the set of current rows.
      If the value is set to <code>true</code>, deleted rows are immediately
      visible with the set of current rows. If the value is set to
      <code>false</code>, the deleted rows are set as invisible with the
      current set of rows.
      <p>
      Standard rowset implementations may choose to restrict this behavior
      due to security considerations or to better fit certain deployment
      scenarios. This is left as implementations defined and does not
      represent standard behavior.
      @param b <code>true</code> if deleted rows should be shown;
                   <code>false</code> otherwise
      @exception SQLException if a rowset implementation is unable to
      to reset whether deleted rows should be visible
      @see #getShowDeleted</p></div>
<a id="L1471" name="L1471"></a>1471     <strong class="reserved">public</strong> <strong class="reserved">void</strong> setShowDeleted(<strong class="reserved">boolean</strong> b) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1472" name="L1472"></a>1472 
<div class="comment">
      Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains
      a <code>Connection</code> object from the <code>ResultSet</code> or JDBC
      properties passed to it's constructors. This method wraps the
      <code>Connection</code> commit method to allow flexible
      auto commit or non auto commit transactional control support.
      <p>
      Makes all changes that are performed by the <code>acceptChanges()</code>
      method since the previous commit/rollback permanent. This method should
      be used only when auto-commit mode has been disabled.
      @throws SQLException if a database access error occurs or this
      Connection object within this <code>CachedRowSet</code> is in auto-commit mode
      @see java.sql.Connection#setAutoCommit</p></div>
<a id="L1488" name="L1488"></a>1488     <strong class="reserved">public</strong> <strong class="reserved">void</strong> <a href="../R/11674.html" title="Multiple referred from 3 places.">commit</a>() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1489" name="L1489"></a>1489 
<div class="comment">
      Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains
      a <code>Connection</code> object from the original <code>ResultSet</code>
      or JDBC properties passed to it.
      <p>
      Undoes all changes made in the current transaction.  This method
      should be used only when auto-commit mode has been disabled.
      @throws SQLException if a database access error occurs or this Connection
      object within this <code>CachedRowSet</code> is in auto-commit mode.</p></div>
<a id="L1501" name="L1501"></a>1501     <strong class="reserved">public</strong> <strong class="reserved">void</strong> rollback() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1502" name="L1502"></a>1502 
<div class="comment">
      Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains
      a <code>Connection</code> object from the original <code>ResultSet</code>
      or JDBC properties passed to it.
      <p>
      Undoes all changes made in the current transaction back to the last
      <code>Savepoint</code> transaction marker. This method should be used only
      when auto-commit mode has been disabled.
      @param s A <code>Savepoint</code> transaction marker
      @throws SQLException if a database access error occurs or this Connection
      object within this <code>CachedRowSet</code> is in auto-commit mode.</p></div>
<a id="L1516" name="L1516"></a>1516     <strong class="reserved">public</strong> <strong class="reserved">void</strong> rollback(<a href="../S/2569.html#L41" title="Defined at 41 in src/java/sql/Savepoint.java.">Savepoint</a> s) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1517" name="L1517"></a>1517 
<div class="comment">
      Causes the <code>CachedRowSet</code> object's <code>SyncProvider</code>
      to commit the changes when <code>acceptChanges()</code> is called. If
      set to false, the changes will <b>not</b> be committed until one of the
      <code>CachedRowSet</code> interface transaction methods is called.
      @deprecated Because this field is final (it is part of an interface),
       its value cannot be changed.
      @see #commit
      @see #rollback</div>
<a id="L1529" name="L1529"></a>1529     @<a href="../D/2383.html" title="Multiple defined in 2 places.">Deprecated</a>
<a id="L1530" name="L1530"></a>1530     <strong class="reserved">public</strong> <strong class="reserved">static</strong> <strong class="reserved">final</strong> <strong class="reserved">boolean</strong> COMMIT_ON_ACCEPT_CHANGES = <strong class="reserved">true</strong>;
<a id="L1531" name="L1531"></a>1531 
<div class="comment">
      Notifies registered listeners that a RowSet object in the given RowSetEvent
      object has populated a number of additional rows. The <code>numRows</code> parameter
      ensures that this event will only be fired every <code>numRow</code>.
      <p>
      The source of the event can be retrieved with the method event.getSource.
      @param event a <code>RowSetEvent</code> object that contains the
          <code>RowSet</code> object that is the source of the events
      @param numRows when populating, the number of rows interval on which the
          <code>CachedRowSet</code> populated should fire; the default value
          is zero; cannot be less than <code>fetchSize</code> or zero
      @throws SQLException <code>numRows &lt; 0 or numRows &lt; getFetchSize() </code></p></div>
<a id="L1546" name="L1546"></a>1546     <strong class="reserved">public</strong> <strong class="reserved">void</strong> rowSetPopulated(<a href="../S/4478.html#L44" title="Defined at 44 in src/javax/sql/RowSetEvent.java.">RowSetEvent</a> event, <strong class="reserved">int</strong> numRows) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1547" name="L1547"></a>1547 
<div class="comment">
      Populates this <code>CachedRowSet</code> object with data from
      the given <code>ResultSet</code> object. While related to the <code>populate(ResultSet)</code>
      method, an additional parameter is provided to allow starting position within
      the <code>ResultSet</code> from where to populate the CachedRowSet
      instance.
      <p>
      This method can be used as an alternative to the <code>execute</code> method when an
      application has a connection to an open <code>ResultSet</code> object.
      Using the method <code>populate</code> can be more efficient than using
      the version of the <code>execute</code> method that takes no parameters
      because it does not open a new connection and re-execute this
      <code>CachedRowSet</code> object's command. Using the <code>populate</code>
       method is more a matter of convenience when compared to using the version
      of <code>execute</code> that takes a <code>ResultSet</code> object.
      @param startRow the position in the <code>ResultSet</code> from where to start
                     populating the records in this <code>CachedRowSet</code>
      @param rs the <code>ResultSet</code> object containing the data
      to be read into this <code>CachedRowSet</code> object
      @throws SQLException if a null <code>ResultSet</code> object is supplied
      or this <code>CachedRowSet</code> object cannot
      retrieve the associated <code>ResultSetMetaData</code> object
      @see #execute
      @see #populate(ResultSet)
      @see java.sql.ResultSet
      @see java.sql.ResultSetMetaData</p></div>
<a id="L1576" name="L1576"></a>1576     <strong class="reserved">public</strong> <strong class="reserved">void</strong> populate(<a href="../S/2602.html#L148" title="Defined at 148 in src/java/sql/ResultSet.java.">ResultSet</a> rs, <strong class="reserved">int</strong> startRow) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1577" name="L1577"></a>1577 
<div class="comment">
      Sets the <code>CachedRowSet</code> object's page-size. A <code>CachedRowSet</code>
      may be configured to populate itself in page-size sized batches of rows. When
      either <code>populate()</code> or <code>execute()</code> are called, the
      <code>CachedRowSet</code> fetches an additional page according to the
      original SQL query used to populate the RowSet.
      @param size the page-size of the <code>CachedRowSet</code>
      @throws SQLException if an error occurs setting the <code>CachedRowSet</code>
           page size or if the page size is less than 0.</div>
<a id="L1589" name="L1589"></a>1589     <strong class="reserved">public</strong> <strong class="reserved">void</strong> setPageSize(<strong class="reserved">int</strong> <a href="../D/34593.html" title="Multiple defined in 204 places.">size</a>) <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1590" name="L1590"></a>1590 
<div class="comment">
      Returns the page-size for the <code>CachedRowSet</code> object
      @return an <code>int</code> page size</div>
<a id="L1596" name="L1596"></a>1596     <strong class="reserved">public</strong> <strong class="reserved">int</strong> getPageSize();
<a id="L1597" name="L1597"></a>1597 
<div class="comment">
      Increments the current page of the <code>CachedRowSet</code>. This causes
      the <code>CachedRowSet</code> implementation to fetch the next page-size
      rows and populate the RowSet, if remaining rows remain within scope of the
      original SQL query used to populated the RowSet.
      @return true if more pages exist; false if this is the last page
      @throws SQLException if an error occurs fetching the next page, or if this
          method is called prematurely before populate or execute.</div>
<a id="L1608" name="L1608"></a>1608     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> nextPage() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1609" name="L1609"></a>1609 
<div class="comment">
      Decrements the current page of the <code>CachedRowSet</code>. This causes
      the <code>CachedRowSet</code> implementation to fetch the previous page-size
      rows and populate the RowSet. The amount of rows returned in the previous
      page must always remain within scope of the original SQL query used to
      populate the RowSet.
      @return true if the previous page is successfully retrieved; false if this
          is the first page.
      @throws SQLException if an error occurs fetching the previous page, or if
          this method is called prematurely before populate or execute.</div>
<a id="L1622" name="L1622"></a>1622     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> previousPage() <strong class="reserved">throws</strong> <a href="../S/2604.html#L53" title="Defined at 53 in src/java/sql/SQLException.java.">SQLException</a>;
<a id="L1623" name="L1623"></a>1623 
<a id="L1624" name="L1624"></a>1624 <em class="brace">}</em>
</pre>
<hr>
<div class="comment">
/* [&lt;][&gt;]<a href="#L655">[^]</a><a href="#L1622">[v]</a><a href="#TOP">[top]</a>[bottom]<a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
</body></html>