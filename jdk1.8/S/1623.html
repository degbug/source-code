<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>src/java/lang/invoke/MethodHandle.java</title>
<meta name="robots" content="noindex,nofollow">
<meta name="generator" content="GLOBAL-6.6.3">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
<a id="TOP" name="TOP"></a><div class="comment">
/* [&lt;][&gt;]<a href="#L428">[^]</a><a href="#L1439">[v]</a>[top]<a href="#BOTTOM">[bottom]</a><a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
<hr>
<h2 class="header">DEFINITIONS</h2>
This source file includes following definitions.
<ol>
<li><a href="#L428" title="Defined at 428.">Target</a></li>
<li><a href="#L429" title="Defined at 429.">Retention</a></li>
<li><a href="#L445" title="Defined at 445.">type</a></li>
<li><a href="#L481" title="Defined at 481.">invokeExact</a></li>
<li><a href="#L518" title="Defined at 518.">invoke</a></li>
<li><a href="#L537" title="Defined at 537.">invokeBasic</a></li>
<li><a href="#L546" title="Defined at 546.">linkToVirtual</a></li>
<li><a href="#L555" title="Defined at 555.">linkToStatic</a></li>
<li><a href="#L564" title="Defined at 564.">linkToSpecial</a></li>
<li><a href="#L573" title="Defined at 573.">linkToInterface</a></li>
<li><a href="#L625" title="Defined at 625.">invokeWithArguments</a></li>
<li><a href="#L648" title="Defined at 648.">invokeWithArguments</a></li>
<li><a href="#L750" title="Defined at 750.">asType</a></li>
<li><a href="#L764" title="Defined at 764.">asTypeCached</a></li>
<li><a href="#L773" title="Defined at 773.">asTypeUncached</a></li>
<li><a href="#L868" title="Defined at 868.">asSpreader</a></li>
<li><a href="#L883" title="Defined at 883.">asSpreaderChecks</a></li>
<li><a href="#L909" title="Defined at 909.">spreadArrayChecks</a></li>
<li><a href="#L994" title="Defined at 994.">asCollector</a></li>
<li><a href="#L1012" title="Defined at 1012.">asCollectorChecks</a></li>
<li><a href="#L1173" title="Defined at 1173.">asVarargsCollector</a></li>
<li><a href="#L1196" title="Defined at 1196.">isVarargsCollector</a></li>
<li><a href="#L1243" title="Defined at 1243.">asFixedArity</a></li>
<li><a href="#L1275" title="Defined at 1275.">bindTo</a></li>
<li><a href="#L1296" title="Defined at 1296.">toString</a></li>
<li><a href="#L1300" title="Defined at 1300.">standardString</a></li>
<li><a href="#L1306" title="Defined at 1306.">debugString</a></li>
<li><a href="#L1316" title="Defined at 1316.">bindArgumentL</a></li>
<li><a href="#L1321" title="Defined at 1321.">setVarargs</a></li>
<li><a href="#L1331" title="Defined at 1331.">viewAsType</a></li>
<li><a href="#L1343" title="Defined at 1343.">viewAsTypeChecks</a></li>
<li><a href="#L1357" title="Defined at 1357.">internalForm</a></li>
<li><a href="#L1362" title="Defined at 1362.">internalMemberName</a></li>
<li><a href="#L1367" title="Defined at 1367.">internalCallerClass</a></li>
<li><a href="#L1372" title="Defined at 1372.">intrinsicName</a></li>
<li><a href="#L1378" title="Defined at 1378.">withInternalMemberName</a></li>
<li><a href="#L1393" title="Defined at 1393.">isInvokeSpecial</a></li>
<li><a href="#L1398" title="Defined at 1398.">internalValues</a></li>
<li><a href="#L1403" title="Defined at 1403.">internalProperties</a></li>
<li><a href="#L1413" title="Defined at 1413.">copyWith</a></li>
<li><a href="#L1419" title="Defined at 1419.">rebind</a></li>
<li><a href="#L1429" title="Defined at 1429.">updateForm</a></li>
<li><a href="#L1439" title="Defined at 1439.">customize</a></li>
</ol>
<hr>
<pre>
<div class="comment">
  Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</div>
<a id="L25" name="L25"></a>  25 
<a id="L26" name="L26"></a>  26 <strong class="reserved">package</strong> <a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.lang.<a href="../D/25050.html" title="Multiple defined in 52 places.">invoke</a>;
<a id="L27" name="L27"></a>  27 
<a id="L28" name="L28"></a>  28 
<a id="L29" name="L29"></a>  29 <strong class="reserved">import</strong> java.util.*;
<a id="L30" name="L30"></a>  30 
<a id="L31" name="L31"></a>  31 <strong class="reserved">import</strong> static java.lang.invoke.MethodHandleStatics.*;
<a id="L32" name="L32"></a>  32 
<div class="comment">
  A method handle is a typed, directly executable reference to an underlying method,
  constructor, field, or similar low-level operation, with optional
  transformations of arguments or return values.
  These transformations are quite general, and include such patterns as
  {@linkplain #asType conversion},
  {@linkplain #bindTo insertion},
  {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},
  and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.
  <h1>Method handle contents</h1>
  Method handles are dynamically and strongly typed according to their parameter and return types.
  They are not distinguished by the name or the defining class of their underlying methods.
  A method handle must be invoked using a symbolic type descriptor which matches
  the method handle's own {@linkplain #type type descriptor}.
  <p>
  Every method handle reports its type descriptor via the {@link #type type} accessor.
  This type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,
  whose structure is a series of classes, one of which is
  the return type of the method (or <code>void.class</code> if none).
  </p><p>
  A method handle's type controls the types of invocations it accepts,
  and the kinds of transformations that apply to it.
  </p><p>
  A method handle contains a pair of special invoker methods
  called {@link #invokeExact invokeExact} and {@link #invoke invoke}.
  Both invoker methods provide direct access to the method handle's
  underlying method, constructor, field, or other operation,
  as modified by transformations of arguments and return values.
  Both invokers accept calls which exactly match the method handle's own type.
  The plain, inexact invoker also accepts a range of other call types.
  </p><p>
  Method handles are immutable and have no visible state.
  Of course, they can be bound to underlying methods or data which exhibit state.
  With respect to the Java Memory Model, any method handle will behave
  as if all of its (internal) fields are final variables.  This means that any method
  handle made visible to the application will always be fully formed.
  This is true even if the method handle is published through a shared
  variable in a data race.
  </p><p>
  Method handles cannot be subclassed by the user.
  Implementations may (or may not) create internal subclasses of <code>MethodHandle</code>
  which may be visible via the {@link java.lang.Object#getClass Object.getClass}
  operation.  The programmer should not draw conclusions about a method handle
  from its specific class, as the method handle class hierarchy (if any)
  may change from time to time or across implementations from different vendors.
  </p><h1>Method handle compilation</h1>
  A Java method call expression naming <code>invokeExact</code> or <code>invoke</code>
  can invoke a method handle from Java source code.
  From the viewpoint of source code, these methods can take any arguments
  and their result can be cast to any return type.
  Formally this is accomplished by giving the invoker methods
  <code>Object</code> return types and variable arity <code>Object</code> arguments,
  but they have an additional quality called <em>signature polymorphism</em>
  which connects this freedom of invocation directly to the JVM execution stack.
  <p>
  As is usual with virtual methods, source-level calls to <code>invokeExact</code>
  and <code>invoke</code> compile to an <code>invokevirtual</code> instruction.
  More unusually, the compiler must record the actual argument types,
  and may not perform method invocation conversions on the arguments.
  Instead, it must push them on the stack according to their own unconverted types.
  The method handle object itself is pushed on the stack before the arguments.
  The compiler then calls the method handle with a symbolic type descriptor which
  describes the argument and return types.
  </p><p>
  To issue a complete symbolic type descriptor, the compiler must also determine
  the return type.  This is based on a cast on the method invocation expression,
  if there is one, or else <code>Object</code> if the invocation is an expression
  or else <code>void</code> if the invocation is a statement.
  The cast may be to a primitive type (but not <code>void</code>).
  </p><p>
  As a corner case, an uncasted <code>null</code> argument is given
  a symbolic type descriptor of <code>java.lang.Void</code>.
  The ambiguity with the type <code>Void</code> is harmless, since there are no references of type
  <code>Void</code> except the null reference.
  </p><h1>Method handle invocation</h1>
  The first time a <code>invokevirtual</code> instruction is executed
  it is linked, by symbolically resolving the names in the instruction
  and verifying that the method call is statically legal.
  This is true of calls to <code>invokeExact</code> and <code>invoke</code>.
  In this case, the symbolic type descriptor emitted by the compiler is checked for
  correct syntax and names it contains are resolved.
  Thus, an <code>invokevirtual</code> instruction which invokes
  a method handle will always link, as long
  as the symbolic type descriptor is syntactically well-formed
  and the types exist.
  <p>
  When the <code>invokevirtual</code> is executed after linking,
  the receiving method handle's type is first checked by the JVM
  to ensure that it matches the symbolic type descriptor.
  If the type match fails, it means that the method which the
  caller is invoking is not present on the individual
  method handle being invoked.
  </p><p>
  In the case of <code>invokeExact</code>, the type descriptor of the invocation
  (after resolving symbolic type names) must exactly match the method type
  of the receiving method handle.
  In the case of plain, inexact <code>invoke</code>, the resolved type descriptor
  must be a valid argument to the receiver's {@link #asType asType} method.
  Thus, plain <code>invoke</code> is more permissive than <code>invokeExact</code>.
  </p><p>
  After type matching, a call to <code>invokeExact</code> directly
  and immediately invoke the method handle's underlying method
  (or other behavior, as the case may be).
  </p><p>
  A call to plain <code>invoke</code> works the same as a call to
  <code>invokeExact</code>, if the symbolic type descriptor specified by the caller
  exactly matches the method handle's own type.
  If there is a type mismatch, <code>invoke</code> attempts
  to adjust the type of the receiving method handle,
  as if by a call to {@link #asType asType},
  to obtain an exactly invokable method handle <code>M2</code>.
  This allows a more powerful negotiation of method type
  between caller and callee.
  </p><p>
  (<em>Note:</em> The adjusted method handle <code>M2</code> is not directly observable,
  and implementations are therefore not required to materialize it.)
  </p><h1>Invocation checking</h1>
  In typical programs, method handle type matching will usually succeed.
  But if a match fails, the JVM will throw a {@link WrongMethodTypeException},
  either directly (in the case of <code>invokeExact</code>) or indirectly as if
  by a failed call to <code>asType</code> (in the case of <code>invoke</code>).
  <p>
  Thus, a method type mismatch which might show up as a linkage error
  in a statically typed program can show up as
  a dynamic <code>WrongMethodTypeException</code>
  in a program which uses method handles.
  </p><p>
  Because method types contain "live" <code>Class</code> objects,
  method type matching takes into account both types names and class loaders.
  Thus, even if a method handle <code>M</code> is created in one
  class loader <code>L1</code> and used in another <code>L2</code>,
  method handle calls are type-safe, because the caller's symbolic type
  descriptor, as resolved in <code>L2</code>,
  is matched against the original callee method's symbolic type descriptor,
  as resolved in <code>L1</code>.
  The resolution in <code>L1</code> happens when <code>M</code> is created
  and its type is assigned, while the resolution in <code>L2</code> happens
  when the <code>invokevirtual</code> instruction is linked.
  </p><p>
  Apart from the checking of type descriptors,
  a method handle's capability to call its underlying method is unrestricted.
  If a method handle is formed on a non-public method by a class
  that has access to that method, the resulting handle can be used
  in any place by any caller who receives a reference to it.
  </p><p>
  Unlike with the Core Reflection API, where access is checked every time
  a reflective method is invoked,
  method handle access checking is performed
  <a href="MethodHandles.Lookup.html#access">when the method handle is created</a>.
  In the case of <code>ldc</code> (see below), access checking is performed as part of linking
  the constant pool entry underlying the constant method handle.
  </p><p>
  Thus, handles to non-public methods, or to methods in non-public classes,
  should generally be kept secret.
  They should not be passed to untrusted code unless their use from
  the untrusted code would be harmless.
  </p><h1>Method handle creation</h1>
  Java code can create a method handle that directly accesses
  any method, constructor, or field that is accessible to that code.
  This is done via a reflective, capability-based API called
  {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}
  For example, a static method handle can be obtained
  from {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.
  There are also conversion methods from Core Reflection API objects,
  such as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
  <p>
  Like classes and strings, method handles that correspond to accessible
  fields, methods, and constructors can also be represented directly
  in a class file's constant pool as constants to be loaded by <code>ldc</code> bytecodes.
  A new type of constant pool entry, <code>CONSTANT_MethodHandle</code>,
  refers directly to an associated <code>CONSTANT_Methodref</code>,
  <code>CONSTANT_InterfaceMethodref</code>, or <code>CONSTANT_Fieldref</code>
  constant pool entry.
  (For full details on method handle constants,
  see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
  </p><p>
  Method handles produced by lookups or constant loads from methods or
  constructors with the variable arity modifier bit (<code>0x0080</code>)
  have a corresponding variable arity, as if they were defined with
  the help of {@link #asVarargsCollector asVarargsCollector}.
  </p><p>
  A method reference may refer either to a static or non-static method.
  In the non-static case, the method handle type includes an explicit
  receiver argument, prepended before any other arguments.
  In the method handle's type, the initial receiver argument is typed
  according to the class under which the method was initially requested.
  (E.g., if a non-static method handle is obtained via <code>ldc</code>,
  the type of the receiver is the class named in the constant pool entry.)
  </p><p>
  Method handle constants are subject to the same link-time access checks
  their corresponding bytecode instructions, and the <code>ldc</code> instruction
  will throw corresponding linkage errors if the bytecode behaviors would
  throw such errors.
  </p><p>
  As a corollary of this, access to protected members is restricted
  to receivers only of the accessing class, or one of its subclasses,
  and the accessing class must in turn be a subclass (or package sibling)
  of the protected member's defining class.
  If a method reference refers to a protected non-static method or field
  of a class outside the current package, the receiver argument will
  be narrowed to the type of the accessing class.
  </p><p>
  When a method handle to a virtual method is invoked, the method is
  always looked up in the receiver (that is, the first argument).
  </p><p>
  A non-virtual method handle to a specific virtual method implementation
  can also be created.  These do not perform virtual lookup based on
  receiver type.  Such a method handle simulates the effect of
  an <code>invokespecial</code> instruction to the same method.
  </p><h1>Usage examples</h1>
  Here are some examples of usage:
  <blockquote><pre>{@code
Object x, y; String s; int i;
MethodType mt; MethodHandle mh;
MethodHandles.Lookup lookup = MethodHandles.lookup();
// mt is (char,char)String
mt = MethodType.methodType(String.class, char.class, char.class);
mh = lookup.findVirtual(String.class, "replace", mt);
s = (String) mh.invokeExact("daddy",'d','n');
// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
assertEquals(s, "nanny");
// weakly typed invocation (using MHs.invoke)
s = (String) mh.invokeWithArguments("sappy", 'p', 'v');
assertEquals(s, "savvy");
// mt is (Object[])List
mt = MethodType.methodType(java.util.List.class, Object[].class);
mh = lookup.findStatic(java.util.Arrays.class, "asList", mt);
assert(mh.isVarargsCollector());
x = mh.invoke("one", "two");
// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList("one","two"));
// mt is (Object,Object,Object)Object
mt = MethodType.genericMethodType(3);
mh = mh.asType(mt);
x = mh.invokeExact((Object)1, (Object)2, (Object)3);
// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList(1,2,3));
// mt is ()int
mt = MethodType.methodType(int.class);
mh = lookup.findVirtual(java.util.List.class, "size", mt);
i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
// invokeExact(Ljava/util/List;)I
assert(i == 3);
mt = MethodType.methodType(void.class, String.class);
mh = lookup.findVirtual(java.io.PrintStream.class, "println", mt);
mh.invokeExact(System.out, "Hello, world.");
// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
  }</pre></blockquote>
  Each of the above calls to <code>invokeExact</code> or plain <code>invoke</code>
  generates a single invokevirtual instruction with
  the symbolic type descriptor indicated in the following comment.
  In these examples, the helper method <code>assertEquals</code> is assumed to
  be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}
  on its arguments, and asserts that the result is true.
  <h1>Exceptions</h1>
  The methods <code>invokeExact</code> and <code>invoke</code> are declared
  to throw {@link java.lang.Throwable Throwable},
  which is to say that there is no static restriction on what a method handle
  can throw.  Since the JVM does not distinguish between checked
  and unchecked exceptions (other than by their class, of course),
  there is no particular effect on bytecode shape from ascribing
  checked exceptions to method handle invocations.  But in Java source
  code, methods which perform method handle calls must either explicitly
  throw <code>Throwable</code>, or else must catch all
  throwables locally, rethrowing only those which are legal in the context,
  and wrapping ones which are illegal.
  <h1><a name="sigpoly"></a>Signature polymorphism</h1>
  The unusual compilation and linkage behavior of
  <code>invokeExact</code> and plain <code>invoke</code>
  is referenced by the term <em>signature polymorphism</em>.
  As defined in the Java Language Specification,
  a signature polymorphic method is one which can operate with
  any of a wide range of call signatures and return types.
  <p>
  In source code, a call to a signature polymorphic method will
  compile, regardless of the requested symbolic type descriptor.
  As usual, the Java compiler emits an <code>invokevirtual</code>
  instruction with the given symbolic type descriptor against the named method.
  The unusual part is that the symbolic type descriptor is derived from
  the actual argument and return types, not from the method declaration.
  </p><p>
  When the JVM processes bytecode containing signature polymorphic calls,
  it will successfully link any such call, regardless of its symbolic type descriptor.
  (In order to retain type safety, the JVM will guard such calls with suitable
  dynamic type checks, as described elsewhere.)
  </p><p>
  Bytecode generators, including the compiler back end, are required to emit
  untransformed symbolic type descriptors for these methods.
  Tools which determine symbolic linkage are required to accept such
  untransformed descriptors, without reporting linkage errors.
  </p><h1>Interoperation between method handles and the Core Reflection API</h1>
  Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,
  any class member represented by a Core Reflection API object
  can be converted to a behaviorally equivalent method handle.
  For example, a reflective {@link java.lang.reflect.Method Method} can
  be converted to a method handle using
  {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
  The resulting method handles generally provide more direct and efficient
  access to the underlying class members.
  <p>
  As a special case,
  when the Core Reflection API is used to view the signature polymorphic
  methods <code>invokeExact</code> or plain <code>invoke</code> in this class,
  they appear as ordinary non-polymorphic methods.
  Their reflective appearance, as viewed by
  {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
  is unaffected by their special status in this API.
  For example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}
  will report exactly those modifier bits required for any similarly
  declared method, including in this case <code>native</code> and <code>varargs</code> bits.
  </p><p>
  As with any reflected method, these methods (when reflected) may be
  invoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.
  However, such reflective calls do not result in method handle invocations.
  Such a call, if passed the required argument
  (a single one, of type <code>Object[]</code>), will ignore the argument and
  will throw an <code>UnsupportedOperationException</code>.
  </p><p>
  Since <code>invokevirtual</code> instructions can natively
  invoke method handles under any symbolic type descriptor, this reflective view conflicts
  with the normal presentation of these methods via bytecodes.
  Thus, these two native methods, when reflectively viewed by
  <code>Class.getDeclaredMethod</code>, may be regarded as placeholders only.
  </p><p>
  In order to obtain an invoker method for a particular type descriptor,
  use {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},
  or {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.
  The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
  API is also able to return a method handle
  to call <code>invokeExact</code> or plain <code>invoke</code>,
  for any specified type descriptor .
  </p><h1>Interoperation between method handles and Java generics</h1>
  A method handle can be obtained on a method, constructor, or field
  which is declared with Java generic types.
  As with the Core Reflection API, the type of the method handle
  will constructed from the erasure of the source-level type.
  When a method handle is invoked, the types of its arguments
  or the return value cast type may be generic types or type instances.
  If this occurs, the compiler will replace those
  types by their erasures when it constructs the symbolic type descriptor
  for the <code>invokevirtual</code> instruction.
  <p>
  Method handles do not represent
  their function-like types in terms of Java parameterized (generic) types,
  because there are three mismatches between function-like types and parameterized
  Java types.
  </p><ul><li>Method types range over all possible arities,
  from no arguments to up to the  <a href="MethodHandle.html#maxarity">maximum number</a> of allowed arguments.
  Generics are not variadic, and so cannot represent this.</li><li>Method types can specify arguments of primitive types,
  which Java generic types cannot range over.</li><li>Higher order functions over method handles (combinators) are
  often generic across a wide range of function types, including
  those of multiple arities.  It is impossible to represent such
  genericity with a Java type parameter.</li>
  </ul>
  <h1><a name="maxarity"></a>Arity limits</h1>
  The JVM imposes on all methods and constructors of any kind an absolute
  limit of 255 stacked arguments.  This limit can appear more restrictive
  in certain cases:
  <ul><li>A <code>long</code> or <code>double</code> argument counts (for purposes of arity limits) as two argument slots.
  </li><li>A non-static method consumes an extra argument for the object on which the method is called.
  </li><li>A constructor consumes an extra argument for the object which is being constructed.
  </li><li>Since a method handle’s <code>invoke</code> method (or other signature-polymorphic method) is non-virtual,
      it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.
  </li></ul>
  These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.
  For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.
  Attempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.
  In particular, a method handle’s type must not have an arity of the exact maximum 255.
  @see MethodType
  @see MethodHandles
  @author John Rose, JSR 292 EG</div>
<a id="L421" name="L421"></a> 421 <strong class="reserved">public</strong> <strong class="reserved">abstract</strong> <strong class="reserved">class</strong> <a href="../R/5115.html" title="Multiple referred from 437 places.">MethodHandle</a> <em class="brace">{</em>
<a id="L422" name="L422"></a> 422     <strong class="reserved">static</strong> <em class="brace">{</em> <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../S/1634.html#L66" title="Defined at 66 in src/java/lang/invoke/MethodHandleImpl.java.">initStatics</a>(); <em class="brace">}</em>
<a id="L423" name="L423"></a> 423 
<div class="comment">
      Internal marker interface which distinguishes (to the Java compiler)
      those methods which are <a href="MethodHandle.html#sigpoly">signature polymorphic</a>.</div>
<a id="L428" name="L428"></a> 428     @<a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.lang.annotation.<a href="../R/8028.html" title="Multiple referred from 50 places.">Target</a>(<em class="brace">{</em><a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.lang.annotation.<a href="../S/1707.html#L73" title="Defined at 73 in src/java/lang/annotation/ElementType.java.">ElementType</a>.<a href="../S/6524.html#L183" title="Defined at 183 in src/com/sun/source/tree/Tree.java.">METHOD</a><em class="brace">}</em>)
<a id="L429" name="L429"></a> 429     @<a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.lang.annotation.<a href="../R/6706.html" title="Multiple referred from 50 places.">Retention</a>(<a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.lang.annotation.<a href="../S/1709.html#L37" title="Defined at 37 in src/java/lang/annotation/RetentionPolicy.java.">RetentionPolicy</a>.<a href="../S/1697.html#L164" title="Defined at 164 in src/java/lang/management/PlatformComponent.java.">RUNTIME</a>)
<a id="L430" name="L430"></a> 430     @<strong class="reserved">interface</strong> <a href="../R/6148.html" title="Multiple referred from 7 places.">PolymorphicSignature</a> <em class="brace">{</em> <em class="brace">}</em>
<a id="L431" name="L431"></a> 431 
<a id="L432" name="L432"></a> 432     <strong class="reserved">private</strong> <strong class="reserved">final</strong> <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>;
<div class="comment">
     /*private*/</div> <strong class="reserved">final</strong> <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> <a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>;
<a id="L434" name="L434"></a> 434     <em class="comment">// form is not private so that invokers can easily fetch it</em>
<div class="comment">
     /*private*/</div> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> asTypeCache;
<a id="L436" name="L436"></a> 436     <em class="comment">// asTypeCache is not private so that invokers can easily fetch it</em>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">byte</strong> customizationCount;
<a id="L438" name="L438"></a> 438     <em class="comment">// customizationCount should be accessible from invokers</em>
<a id="L439" name="L439"></a> 439 
<div class="comment">
      Reports the type of this method handle.
      Every invocation of this method handle via <code>invokeExact</code> must exactly match this type.
      @return the method handle type</div>
<a id="L445" name="L445"></a> 445     <strong class="reserved">public</strong> <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> <a href="../R/29570.html" title="Multiple referred from 5977 places.">type</a>() <em class="brace">{</em>
<a id="L446" name="L446"></a> 446         <strong class="reserved">return</strong> <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>;
<a id="L447" name="L447"></a> 447     <em class="brace">}</em>
<a id="L448" name="L448"></a> 448 
<div class="comment">
      Package-private constructor for the method handle implementation hierarchy.
      Method handle inheritance will be contained completely within
      the <code>java.lang.invoke</code> package.</div>
<a id="L454" name="L454"></a> 454     <em class="comment">// @param type type (permanently assigned) of the new method handle</em>
<div class="comment">
     /*non-public*/</div> MethodHandle(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>, <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> <a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>) <em class="brace">{</em>
<a id="L456" name="L456"></a> 456         <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>.<a href="../D/17675.html" title="Multiple defined in 6 places.">getClass</a>();  <em class="comment">// explicit NPE</em>
<a id="L457" name="L457"></a> 457         <a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>.<a href="../D/17675.html" title="Multiple defined in 6 places.">getClass</a>();  <em class="comment">// explicit NPE</em>
<a id="L458" name="L458"></a> 458         <strong class="reserved">this</strong>.<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a> = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>;
<a id="L459" name="L459"></a> 459         <strong class="reserved">this</strong>.<a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a> = <a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>.<a href="../S/1626.html#L390" title="Defined at 390 in src/java/lang/invoke/LambdaForm.java.">uncustomize</a>();
<a id="L460" name="L460"></a> 460 
<a id="L461" name="L461"></a> 461         <strong class="reserved">this</strong>.<a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>.<a href="../D/29556.html" title="Multiple defined in 6 places.">prepare</a>();  <em class="comment">// TO DO:  Try to delay this step until just before invocation.</em>
<a id="L462" name="L462"></a> 462     <em class="brace">}</em>
<a id="L463" name="L463"></a> 463 
<div class="comment">
      Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.
      The symbolic type descriptor at the call site of <code>invokeExact</code> must
      exactly match this method handle's {@link #type type}.
      No conversions are allowed on arguments or return values.
      <p>
      When this method is observed via the Core Reflection API,
      it will appear as a single native method, taking an object array and returning an object.
      If this native method is invoked directly via
      {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,
      or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},
      it will throw an <code>UnsupportedOperationException</code>.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code>
      @throws WrongMethodTypeException if the target's type is not identical with the caller's symbolic type descriptor
      @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call</p></div>
<a id="L481" name="L481"></a> 481     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../R/21065.html" title="Multiple referred from 7 places.">invokeExact</a>(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L482" name="L482"></a> 482 
<div class="comment">
      Invokes the method handle, allowing any caller type descriptor,
      and optionally performing conversions on arguments and return values.
      <p>
      If the call site's symbolic type descriptor exactly matches this method handle's {@link #type type},
      the call proceeds as if by {@link #invokeExact invokeExact}.
      </p><p>
      Otherwise, the call proceeds as if this method handle were first
      adjusted by calling {@link #asType asType} to adjust this method handle
      to the required type, and then the call proceeds as if by
      {@link #invokeExact invokeExact} on the adjusted method handle.
      </p><p>
      There is no guarantee that the <code>asType</code> call is actually made.
      If the JVM can predict the results of making the call, it may perform
      adaptations directly on the caller's arguments,
      and call the target method handle according to its own exact type.
      </p><p>
      The resolved type descriptor at the call site of <code>invoke</code> must
      be a valid argument to the receivers <code>asType</code> method.
      In particular, the caller must specify the same argument arity
      as the callee's type,
      if the callee is not a {@linkplain #asVarargsCollector variable arity collector}.
      </p><p>
      When this method is observed via the Core Reflection API,
      it will appear as a single native method, taking an object array and returning an object.
      If this native method is invoked directly via
      {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,
      or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},
      it will throw an <code>UnsupportedOperationException</code>.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code>
      @throws WrongMethodTypeException if the target's type cannot be adjusted to the caller's symbolic type descriptor
      @throws ClassCastException if the target's type can be adjusted to the caller, but a reference cast fails
      @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call</p></div>
<a id="L518" name="L518"></a> 518     <strong class="reserved">public</strong> <strong class="reserved">final</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../R/21052.html" title="Multiple referred from 440 places.">invoke</a>(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L519" name="L519"></a> 519 
<div class="comment">
      Private method for trusted invocation of a method handle respecting simplified signatures.
      Type mismatches will not throw <code>WrongMethodTypeException</code>, but could crash the JVM.
      <p>
      The caller signature is restricted to the following basic types:
      Object, int, long, float, double, and void return.
      </p><p>
      The caller is responsible for maintaining type correctness by ensuring
      that the each outgoing argument value is a member of the range of the corresponding
      callee argument type.
      (The caller should therefore issue appropriate casts and integer narrowing
      operations on outgoing argument values.)
      The caller can assume that the incoming result value is part of the range
      of the callee's return type.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code></p></div>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">final</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../R/21057.html" title="Multiple referred from 38 places.">invokeBasic</a>(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L538" name="L538"></a> 538 
<div class="comment">
      Private method for trusted invocation of a MemberName of kind <code>REF_invokeVirtual</code>.
      The caller signature is restricted to basic types as with <code>invokeBasic</code>.
      The trailing (not leading) argument must be a MemberName.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code></div>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">static</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> linkToVirtual(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L547" name="L547"></a> 547 
<div class="comment">
      Private method for trusted invocation of a MemberName of kind <code>REF_invokeStatic</code>.
      The caller signature is restricted to basic types as with <code>invokeBasic</code>.
      The trailing (not leading) argument must be a MemberName.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code></div>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">static</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> linkToStatic(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L556" name="L556"></a> 556 
<div class="comment">
      Private method for trusted invocation of a MemberName of kind <code>REF_invokeSpecial</code>.
      The caller signature is restricted to basic types as with <code>invokeBasic</code>.
      The trailing (not leading) argument must be a MemberName.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code></div>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">static</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> linkToSpecial(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L565" name="L565"></a> 565 
<div class="comment">
      Private method for trusted invocation of a MemberName of kind <code>REF_invokeInterface</code>.
      The caller signature is restricted to basic types as with <code>invokeBasic</code>.
      The trailing (not leading) argument must be a MemberName.
      @param args the signature-polymorphic parameter list, statically represented using varargs
      @return the signature-polymorphic result, statically represented using <code>Object</code></div>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">static</strong> <strong class="reserved">native</strong> @<a href="../S/1623.html#L430" title="Defined at 430 in src/java/lang/invoke/MethodHandle.java.">PolymorphicSignature</a> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> linkToInterface(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... args) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a>;
<a id="L574" name="L574"></a> 574 
<div class="comment">
      Performs a variable arity invocation, passing the arguments in the given list
      to the method handle, as if via an inexact {@link #invoke invoke} from a call site
      which mentions only the type <code>Object</code>, and whose arity is the length
      of the argument list.
      <p>
      Specifically, execution proceeds as if by the following steps,
      although the methods are not guaranteed to be called if the JVM
      can predict their effects.
      </p><ul><li>Determine the length of the argument array as <code>N</code>.
          For a null reference, <code>N=0</code>. </li><li>Determine the general type <code>TN</code> of <code>N</code> arguments as
          as <code>TN=MethodType.genericMethodType(N)</code>.</li><li>Force the original target method handle <code>MH0</code> to the
          required type, as <code>MH1 = MH0.asType(TN)</code>. </li><li>Spread the array into <code>N</code> separate arguments <code>A0, ...</code>. </li><li>Invoke the type-adjusted method handle on the unpacked arguments:
          MH1.invokeExact(A0, ...). </li><li>Take the return value as an <code>Object</code> reference. </li>
      </ul>
      <p>
      Because of the action of the <code>asType</code> step, the following argument
      conversions are applied as necessary:
      </p><ul><li>reference casting
      </li><li>unboxing
      </li><li>widening primitive conversions
      </li></ul>
      <p>
      The result returned by the call is boxed if it is a primitive,
      or forced to null if the return type is void.
      </p><p>
      This call is equivalent to the following code:
      </p><blockquote><pre>{@code
      MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);
      Object result = invoker.invokeExact(this, arguments);
      }</pre></blockquote>
      <p>
      Unlike the signature polymorphic methods <code>invokeExact</code> and <code>invoke</code>,
      <code>invokeWithArguments</code> can be accessed normally via the Core Reflection API and JNI.
      It can therefore be used as a bridge between native or reflective code and method handles.
      @param arguments the arguments to pass to the target
      @return the result returned by the target
      @throws ClassCastException if an argument cannot be converted by reference casting
      @throws WrongMethodTypeException if the target's type cannot be adjusted to take the given number of <code>Object</code> arguments
      @throws Throwable anything thrown by the target method invocation
      @see MethodHandles#spreadInvoker</p></div>
<a id="L625" name="L625"></a> 625     <strong class="reserved">public</strong> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../R/21094.html" title="Multiple referred from 5 places.">invokeWithArguments</a>(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a>... <a href="../D/11487.html" title="Multiple defined in 15 places.">arguments</a>) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a> <em class="brace">{</em>
<a id="L626" name="L626"></a> 626         <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> invocationType = <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a>.<a href="../D/16672.html" title="Multiple defined in 2 places.">genericMethodType</a>(<a href="../D/11487.html" title="Multiple defined in 15 places.">arguments</a> == <strong class="reserved">null</strong> ? 0 : <a href="../D/11487.html" title="Multiple defined in 15 places.">arguments</a>.<a href="../D/26813.html" title="Multiple defined in 43 places.">length</a>);
<a id="L627" name="L627"></a> 627         <strong class="reserved">return</strong> invocationType.<a href="../S/1616.html#L990" title="Defined at 990 in src/java/lang/invoke/MethodType.java.">invokers</a>().<a href="../D/34734.html" title="Multiple defined in 2 places.">spreadInvoker</a>(0).<a href="../S/1623.html#L481" title="Defined at 481 in src/java/lang/invoke/MethodHandle.java.">invokeExact</a>(<a href="../D/11568.html" title="Multiple defined in 2 places.">asType</a>(invocationType), <a href="../D/11487.html" title="Multiple defined in 15 places.">arguments</a>);
<a id="L628" name="L628"></a> 628     <em class="brace">}</em>
<a id="L629" name="L629"></a> 629 
<div class="comment">
      Performs a variable arity invocation, passing the arguments in the given array
      to the method handle, as if via an inexact {@link #invoke invoke} from a call site
      which mentions only the type <code>Object</code>, and whose arity is the length
      of the argument array.
      <p>
      This method is also equivalent to the following code:
      </p><blockquote><pre>{@code
        invokeWithArguments(arguments.toArray()
      }</pre></blockquote>
      @param arguments the arguments to pass to the target
      @return the result returned by the target
      @throws NullPointerException if <code>arguments</code> is a null reference
      @throws ClassCastException if an argument cannot be converted by reference casting
      @throws WrongMethodTypeException if the target's type cannot be adjusted to take the given number of <code>Object</code> arguments
      @throws Throwable anything thrown by the target method invocation</div>
<a id="L648" name="L648"></a> 648     <strong class="reserved">public</strong> <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../R/21094.html" title="Multiple referred from 5 places.">invokeWithArguments</a>(<a href="../S/3625.html#L43" title="Defined at 43 in src/javax/management/remote/rmi/RMIConnectionImpl_Stub.java.">java</a>.util.<a href="../D/5090.html" title="Multiple defined in 5 places.">List</a>&lt;?&gt; <a href="../D/11487.html" title="Multiple defined in 15 places.">arguments</a>) <strong class="reserved">throws</strong> <a href="../S/1726.html#L114" title="Defined at 114 in src/java/lang/Throwable.java.">Throwable</a> <em class="brace">{</em>
<a id="L649" name="L649"></a> 649         <strong class="reserved">return</strong> <a href="../D/25095.html" title="Multiple defined in 3 places.">invokeWithArguments</a>(<a href="../D/11487.html" title="Multiple defined in 15 places.">arguments</a>.<a href="../D/35348.html" title="Multiple defined in 117 places.">toArray</a>());
<a id="L650" name="L650"></a> 650     <em class="brace">}</em>
<a id="L651" name="L651"></a> 651 
<div class="comment">
      Produces an adapter method handle which adapts the type of the
      current method handle to a new type.
      The resulting method handle is guaranteed to report a type
      which is equal to the desired new type.
      <p>
      If the original type and new type are equal, returns <code>this</code>.
      </p><p>
      The new method handle, when invoked, will perform the following
      steps:
      </p><ul><li>Convert the incoming argument list to match the original
          method handle's argument list.
      </li><li>Invoke the original method handle on the converted argument list.
      </li><li>Convert any result returned by the original method handle
          to the return type of new method handle.
      </li></ul>
      <p>
      This method provides the crucial behavioral difference between
      {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}.
      The two methods
      perform the same steps when the caller's type descriptor exactly m atches
      the callee's, but when the types differ, plain {@link #invoke invoke}
      also calls <code>asType</code> (or some internal equivalent) in order
      to match up the caller's and callee's types.
      </p><p>
      If the current method is a variable arity method handle
      argument list conversion may involve the conversion and collection
      of several arguments into an array, as
      {@linkplain #asVarargsCollector described elsewhere}.
      In every other case, all conversions are applied <em>pairwise</em>,
      which means that each argument or return value is converted to
      exactly one argument or return value (or no return value).
      The applied conversions are defined by consulting the
      the corresponding component types of the old and new
      method handle types.
      </p><p>
      Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types,
      or old and new return types.  Specifically, for some valid index <code>i</code>, let
      <em>T0</em><code>=newType.parameterType(i)</code> and <em>T1</em><code>=this.type().parameterType(i)</code>.
      Or else, going the other way for return values, let
      <em>T0</em><code>=this.type().returnType()</code> and <em>T1</em><code>=newType.returnType()</code>.
      If the types are the same, the new method handle makes no change
      to the corresponding argument or return value (if any).
      Otherwise, one of the following conversions is applied
      if possible:
      </p><ul><li>If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied.
          (The types do not need to be related in any particular way.
          This is because a dynamic value of null can convert to any reference type.)
      </li><li>If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation
          conversion (JLS 5.3) is applied, if one exists.
          (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.)
      </li><li>If <em>T0</em> is a primitive and <em>T1</em> a reference,
          a Java casting conversion (JLS 5.5) is applied if one exists.
          (Specifically, the value is boxed from <em>T0</em> to its wrapper class,
          which is then widened as needed to <em>T1</em>.)
      </li><li>If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing
          conversion will be applied at runtime, possibly followed
          by a Java method invocation conversion (JLS 5.3)
          on the primitive value.  (These are the primitive widening conversions.)
          <em>T0</em> must be a wrapper class or a supertype of one.
          (In the case where <em>T0</em> is Object, these are the conversions
          allowed by {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.)
          The unboxing conversion must have a possibility of success, which means that
          if <em>T0</em> is not itself a wrapper class, there must exist at least one
          wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed
          primitive value can be widened to <em>T1</em>.
      </li><li>If the return type <em>T1</em> is marked as void, any returned value is discarded
      </li><li>If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced.
      </li><li>If the return type <em>T0</em> is void and <em>T1</em> a primitive,
          a zero value is introduced.
      </li></ul>
      (<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types,
      because neither corresponds specifically to the <em>dynamic type</em> of any
      actual argument or return value.)
      <p>
      The method handle conversion cannot be made if any one of the required
      pairwise conversions cannot be made.
      </p><p>
      At runtime, the conversions applied to reference arguments
      or return values may require additional runtime checks which can fail.
      An unboxing operation may fail because the original reference is null,
      causing a {@link java.lang.NullPointerException NullPointerException}.
      An unboxing operation or a reference cast may also fail on a reference
      to an object of the wrong type,
      causing a {@link java.lang.ClassCastException ClassCastException}.
      Although an unboxing operation may accept several kinds of wrappers,
      if none are available, a <code>ClassCastException</code> will be thrown.
      @param newType the expected type of the new method handle
      @return a method handle which delegates to <code>this</code> after performing
                any necessary argument conversions, and arranges for any
                necessary return value conversions
      @throws NullPointerException if <code>newType</code> is a null reference
      @throws WrongMethodTypeException if the conversion cannot be made
      @see MethodHandles#explicitCastArguments</p></div>
<a id="L750" name="L750"></a> 750     <strong class="reserved">public</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/10356.html" title="Multiple referred from 23 places.">asType</a>(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> newType) <em class="brace">{</em>
<a id="L751" name="L751"></a> 751         <em class="comment">// Fast path alternative to a heavyweight {@code asType} call.</em>
<a id="L752" name="L752"></a> 752         <em class="comment">// Return 'this' if the conversion will be a no-op.</em>
<a id="L753" name="L753"></a> 753         <strong class="reserved">if</strong> (newType == <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>) <em class="brace">{</em>
<a id="L754" name="L754"></a> 754             <strong class="reserved">return</strong> <strong class="reserved">this</strong>;
<a id="L755" name="L755"></a> 755         <em class="brace">}</em>
<a id="L756" name="L756"></a> 756         <em class="comment">// Return 'this.asTypeCache' if the conversion is already memoized.</em>
<a id="L757" name="L757"></a> 757         <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> atc = <a href="../S/1623.html#L764" title="Defined at 764 in src/java/lang/invoke/MethodHandle.java.">asTypeCached</a>(newType);
<a id="L758" name="L758"></a> 758         <strong class="reserved">if</strong> (atc != <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L759" name="L759"></a> 759             <strong class="reserved">return</strong> atc;
<a id="L760" name="L760"></a> 760         <em class="brace">}</em>
<a id="L761" name="L761"></a> 761         <strong class="reserved">return</strong> <a href="../D/11570.html" title="Multiple defined in 6 places.">asTypeUncached</a>(newType);
<a id="L762" name="L762"></a> 762     <em class="brace">}</em>
<a id="L763" name="L763"></a> 763 
<a id="L764" name="L764"></a> 764     <strong class="reserved">private</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../S/1623.html#L757" title="Referred from 757 in src/java/lang/invoke/MethodHandle.java.">asTypeCached</a>(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> newType) <em class="brace">{</em>
<a id="L765" name="L765"></a> 765         <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> atc = asTypeCache;
<a id="L766" name="L766"></a> 766         <strong class="reserved">if</strong> (atc != <strong class="reserved">null</strong> &amp;&amp; newType == atc.<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>) <em class="brace">{</em>
<a id="L767" name="L767"></a> 767             <strong class="reserved">return</strong> atc;
<a id="L768" name="L768"></a> 768         <em class="brace">}</em>
<a id="L769" name="L769"></a> 769         <strong class="reserved">return</strong> <strong class="reserved">null</strong>;
<a id="L770" name="L770"></a> 770     <em class="brace">}</em>
<a id="L771" name="L771"></a> 771 
<div class="comment">
     /** Override this to change asType behavior. */</div>
<div class="comment">
     /*non-public*/</div> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../S/1623.html#L761" title="Referred from 761 in src/java/lang/invoke/MethodHandle.java.">asTypeUncached</a>(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> newType) <em class="brace">{</em>
<a id="L774" name="L774"></a> 774         <strong class="reserved">if</strong> (!<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>.<a href="../S/1616.html#L830" title="Defined at 830 in src/java/lang/invoke/MethodType.java.">isConvertibleTo</a>(newType))
<a id="L775" name="L775"></a> 775             <strong class="reserved">throw</strong> <strong class="reserved">new</strong> <a href="../S/1605.html#L43" title="Defined at 43 in src/java/lang/invoke/WrongMethodTypeException.java.">WrongMethodTypeException</a>("cannot convert "+<strong class="reserved">this</strong>+" to "+newType);
<a id="L776" name="L776"></a> 776         <strong class="reserved">return</strong> asTypeCache = <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../D/27364.html" title="Multiple defined in 2 places.">makePairwiseConvert</a>(<strong class="reserved">this</strong>, newType, <strong class="reserved">true</strong>);
<a id="L777" name="L777"></a> 777     <em class="brace">}</em>
<a id="L778" name="L778"></a> 778 
<div class="comment">
      Makes an <em>array-spreading</em> method handle, which accepts a trailing array argument
      and spreads its elements as positional arguments.
      The new method handle adapts, as its <i>target</i>,
      the current method handle.  The type of the adapter will be
      the same as the type of the target, except that the final
      <code>arrayLength</code> parameters of the target's type are replaced
      by a single array parameter of type <code>arrayType</code>.
      <p>
      If the array element type differs from any of the corresponding
      argument types on the original target,
      the original target is adapted to take the array elements directly,
      as if by a call to {@link #asType asType}.
      </p><p>
      When called, the adapter replaces a trailing array argument
      by the array's elements, each as its own argument to the target.
      (The order of the arguments is preserved.)
      They are converted pairwise by casting and/or unboxing
      to the types of the trailing parameters of the target.
      Finally the target is called.
      What the target eventually returns is returned unchanged by the adapter.
      </p><p>
      Before calling the target, the adapter verifies that the array
      contains exactly enough elements to provide a correct argument count
      to the target method handle.
      (The array may also be null when zero elements are required.)
      </p><p>
      If, when the adapter is called, the supplied array argument does
      not have the correct number of elements, the adapter will throw
      an {@link IllegalArgumentException} instead of invoking the target.
      </p><p>
      Here are some simple examples of array-spreading method handles:
      </p><blockquote><pre>{@code
MethodHandle equals = publicLookup()
  .findVirtual(String.class, "equals", methodType(boolean.class, Object.class));
assert( (boolean) equals.invokeExact("me", (Object)"me"));
assert(!(boolean) equals.invokeExact("me", (Object)"thee"));
// spread both arguments from a 2-array:
MethodHandle eq2 = equals.asSpreader(Object[].class, 2);
assert( (boolean) eq2.invokeExact(new Object[]{ "me", "me" }));
assert(!(boolean) eq2.invokeExact(new Object[]{ "me", "thee" }));
// try to spread from anything but a 2-array:
for (int n = 0; n &lt;= 10; n++) {
  Object[] badArityArgs = (n == 2 ? null : new Object[n]);
  try { assert((boolean) eq2.invokeExact(badArityArgs) &amp;&amp; false); }
  catch (IllegalArgumentException ex) { } // OK
}
// spread both arguments from a String array:
MethodHandle eq2s = equals.asSpreader(String[].class, 2);
assert( (boolean) eq2s.invokeExact(new String[]{ "me", "me" }));
assert(!(boolean) eq2s.invokeExact(new String[]{ "me", "thee" }));
// spread second arguments from a 1-array:
MethodHandle eq1 = equals.asSpreader(Object[].class, 1);
assert( (boolean) eq1.invokeExact("me", new Object[]{ "me" }));
assert(!(boolean) eq1.invokeExact("me", new Object[]{ "thee" }));
// spread no arguments from a 0-array or null:
MethodHandle eq0 = equals.asSpreader(Object[].class, 0);
assert( (boolean) eq0.invokeExact("me", (Object)"me", new Object[0]));
assert(!(boolean) eq0.invokeExact("me", (Object)"thee", (Object[])null));
// asSpreader and asCollector are approximate inverses:
for (int n = 0; n &lt;= 2; n++) {
    for (Class<!--?--> a : new Class<!--?-->[]{Object[].class, String[].class, CharSequence[].class}) {
        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);
        assert( (boolean) equals2.invokeWithArguments("me", "me"));
        assert(!(boolean) equals2.invokeWithArguments("me", "thee"));
    }
}
MethodHandle caToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, char[].class));
assertEquals("[A, B, C]", (String) caToString.invokeExact("ABC".toCharArray()));
MethodHandle caString3 = caToString.asCollector(char[].class, 3);
assertEquals("[A, B, C]", (String) caString3.invokeExact('A', 'B', 'C'));
MethodHandle caToString2 = caString3.asSpreader(char[].class, 2);
assertEquals("[A, B, C]", (String) caToString2.invokeExact('A', "BC".toCharArray()));
      }</pre></blockquote>
      @param arrayType usually <code>Object[]</code>, the type of the array argument from which to extract the spread arguments
      @param arrayLength the number of arguments to spread from an incoming array argument
      @return a new method handle which spreads its final array argument,
              before calling the original method handle
      @throws NullPointerException if <code>arrayType</code> is a null reference
      @throws IllegalArgumentException if <code>arrayType</code> is not an array type,
              or if target does not have at least
              <code>arrayLength</code> parameter types,
              or if <code>arrayLength</code> is negative,
              or if the resulting method handle's type would have
              <a href="MethodHandle.html#maxarity">too many parameters</a>
      @throws WrongMethodTypeException if the implied <code>asType</code> call fails
      @see #asCollector</div>
<a id="L868" name="L868"></a> 868     <strong class="reserved">public</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/10351.html" title="Multiple referred from 3 places.">asSpreader</a>(<a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType, <strong class="reserved">int</strong> <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>) <em class="brace">{</em>
<a id="L869" name="L869"></a> 869         <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> postSpreadType = <a href="../S/1623.html#L883" title="Defined at 883 in src/java/lang/invoke/MethodHandle.java.">asSpreaderChecks</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L870" name="L870"></a> 870         <strong class="reserved">int</strong> <a href="../D/11492.html" title="Multiple defined in 3 places.">arity</a> = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/29054.html" title="Multiple defined in 2 places.">parameterCount</a>();
<a id="L871" name="L871"></a> 871         <strong class="reserved">int</strong> spreadArgPos = <a href="../D/11492.html" title="Multiple defined in 3 places.">arity</a> - <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>;
<a id="L872" name="L872"></a> 872         <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> afterSpread = <strong class="reserved">this</strong>.<a href="../D/11568.html" title="Multiple defined in 2 places.">asType</a>(postSpreadType);
<a id="L873" name="L873"></a> 873         <a href="../S/1606.html#L53" title="Defined at 53 in src/java/lang/invoke/BoundMethodHandle.java.">BoundMethodHandle</a> mh = afterSpread.<a href="../D/30364.html" title="Multiple defined in 23 places.">rebind</a>();
<a id="L874" name="L874"></a> 874         <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> lform = mh.<a href="../D/15284.html" title="Multiple defined in 2 places.">editor</a>().<a href="../S/1629.html#L518" title="Defined at 518 in src/java/lang/invoke/LambdaFormEditor.java.">spreadArgumentsForm</a>(1 + spreadArgPos, arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L875" name="L875"></a> 875         <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> preSpreadType = postSpreadType.<a href="../S/1616.html#L457" title="Defined at 457 in src/java/lang/invoke/MethodType.java.">replaceParameterTypes</a>(spreadArgPos, <a href="../D/11492.html" title="Multiple defined in 3 places.">arity</a>, arrayType);
<a id="L876" name="L876"></a> 876         <strong class="reserved">return</strong> mh.<a href="../D/13534.html" title="Multiple defined in 10 places.">copyWith</a>(preSpreadType, lform);
<a id="L877" name="L877"></a> 877     <em class="brace">}</em>
<a id="L878" name="L878"></a> 878 
<div class="comment">
      See if <code>asSpreader</code> can be validly called with the given arguments.
      Return the type of the method handle call after spreading but before conversions.</div>
<a id="L883" name="L883"></a> 883     <strong class="reserved">private</strong> <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> <a href="../S/1623.html#L869" title="Referred from 869 in src/java/lang/invoke/MethodHandle.java.">asSpreaderChecks</a>(<a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType, <strong class="reserved">int</strong> <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>) <em class="brace">{</em>
<a id="L884" name="L884"></a> 884         <a href="../S/1623.html#L909" title="Defined at 909 in src/java/lang/invoke/MethodHandle.java.">spreadArrayChecks</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L885" name="L885"></a> 885         <strong class="reserved">int</strong> nargs = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/29054.html" title="Multiple defined in 2 places.">parameterCount</a>();
<a id="L886" name="L886"></a> 886         <strong class="reserved">if</strong> (nargs &lt; <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a> || <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a> &lt; 0)
<a id="L887" name="L887"></a> 887             <strong class="reserved">throw</strong> <a href="../D/28010.html" title="Multiple defined in 3 places.">newIllegalArgumentException</a>("bad spread array length");
<a id="L888" name="L888"></a> 888         <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayElement = arrayType.<a href="../D/17880.html" title="Multiple defined in 2 places.">getComponentType</a>();
<a id="L889" name="L889"></a> 889         <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> mtype = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>();
<a id="L890" name="L890"></a> 890         <strong class="reserved">boolean</strong> <a href="../D/27519.html" title="Multiple defined in 69 places.">match</a> = <strong class="reserved">true</strong>, <a href="../D/15966.html" title="Multiple defined in 7 places.">fail</a> = <strong class="reserved">false</strong>;
<a id="L891" name="L891"></a> 891         <strong class="reserved">for</strong> (<strong class="reserved">int</strong> i = nargs - <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>; i &lt; nargs; i++) <em class="brace">{</em>
<a id="L892" name="L892"></a> 892             <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; ptype = mtype.<a href="../D/29061.html" title="Multiple defined in 3 places.">parameterType</a>(i);
<a id="L893" name="L893"></a> 893             <strong class="reserved">if</strong> (ptype != arrayElement) <em class="brace">{</em>
<a id="L894" name="L894"></a> 894                 <a href="../D/27519.html" title="Multiple defined in 69 places.">match</a> = <strong class="reserved">false</strong>;
<a id="L895" name="L895"></a> 895                 <strong class="reserved">if</strong> (!<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a>.<a href="../S/1616.html#L922" title="Defined at 922 in src/java/lang/invoke/MethodType.java.">canConvert</a>(arrayElement, ptype)) <em class="brace">{</em>
<a id="L896" name="L896"></a> 896                     <a href="../D/15966.html" title="Multiple defined in 7 places.">fail</a> = <strong class="reserved">true</strong>;
<a id="L897" name="L897"></a> 897                     <strong class="reserved">break</strong>;
<a id="L898" name="L898"></a> 898                 <em class="brace">}</em>
<a id="L899" name="L899"></a> 899             <em class="brace">}</em>
<a id="L900" name="L900"></a> 900         <em class="brace">}</em>
<a id="L901" name="L901"></a> 901         <strong class="reserved">if</strong> (<a href="../D/27519.html" title="Multiple defined in 69 places.">match</a>)  <strong class="reserved">return</strong> mtype;
<a id="L902" name="L902"></a> 902         <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> needType = mtype.<a href="../S/1616.html#L474" title="Defined at 474 in src/java/lang/invoke/MethodType.java.">asSpreaderType</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L903" name="L903"></a> 903         <strong class="reserved">if</strong> (!<a href="../D/15966.html" title="Multiple defined in 7 places.">fail</a>)  <strong class="reserved">return</strong> needType;
<a id="L904" name="L904"></a> 904         <em class="comment">// elicit an error:</em>
<a id="L905" name="L905"></a> 905         <strong class="reserved">this</strong>.<a href="../D/11568.html" title="Multiple defined in 2 places.">asType</a>(needType);
<a id="L906" name="L906"></a> 906         <strong class="reserved">throw</strong> <a href="../D/28023.html" title="Multiple defined in 3 places.">newInternalError</a>("should not return", <strong class="reserved">null</strong>);
<a id="L907" name="L907"></a> 907     <em class="brace">}</em>
<a id="L908" name="L908"></a> 908 
<a id="L909" name="L909"></a> 909     <strong class="reserved">private</strong> <strong class="reserved">void</strong> <a href="../R/28766.html" title="Multiple referred from 2 places.">spreadArrayChecks</a>(<a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType, <strong class="reserved">int</strong> <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>) <em class="brace">{</em>
<a id="L910" name="L910"></a> 910         <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayElement = arrayType.<a href="../D/17880.html" title="Multiple defined in 2 places.">getComponentType</a>();
<a id="L911" name="L911"></a> 911         <strong class="reserved">if</strong> (arrayElement == <strong class="reserved">null</strong>)
<a id="L912" name="L912"></a> 912             <strong class="reserved">throw</strong> <a href="../D/28010.html" title="Multiple defined in 3 places.">newIllegalArgumentException</a>("not an array type", arrayType);
<a id="L913" name="L913"></a> 913         <strong class="reserved">if</strong> ((<a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a> &amp; 0x7F) != <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>) <em class="brace">{</em>
<a id="L914" name="L914"></a> 914             <strong class="reserved">if</strong> ((<a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a> &amp; 0xFF) != <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>)
<a id="L915" name="L915"></a> 915                 <strong class="reserved">throw</strong> <a href="../D/28010.html" title="Multiple defined in 3 places.">newIllegalArgumentException</a>("array length is not legal", <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L916" name="L916"></a> 916             <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(<a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a> &gt;= 128);
<a id="L917" name="L917"></a> 917             <strong class="reserved">if</strong> (arrayElement == <strong class="reserved">long</strong>.<strong class="reserved">class</strong> ||
<a id="L918" name="L918"></a> 918                 arrayElement == <strong class="reserved">double</strong>.<strong class="reserved">class</strong>)
<a id="L919" name="L919"></a> 919                 <strong class="reserved">throw</strong> <a href="../D/28010.html" title="Multiple defined in 3 places.">newIllegalArgumentException</a>("array length is not legal for long[] or double[]", <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L920" name="L920"></a> 920         <em class="brace">}</em>
<a id="L921" name="L921"></a> 921     <em class="brace">}</em>
<a id="L922" name="L922"></a> 922 
<div class="comment">
      Makes an <em>array-collecting</em> method handle, which accepts a given number of trailing
      positional arguments and collects them into an array argument.
      The new method handle adapts, as its <i>target</i>,
      the current method handle.  The type of the adapter will be
      the same as the type of the target, except that a single trailing
      parameter (usually of type <code>arrayType</code>) is replaced by
      <code>arrayLength</code> parameters whose type is element type of <code>arrayType</code>.
      <p>
      If the array type differs from the final argument type on the original target,
      the original target is adapted to take the array type directly,
      as if by a call to {@link #asType asType}.
      </p><p>
      When called, the adapter replaces its trailing <code>arrayLength</code>
      arguments by a single new array of type <code>arrayType</code>, whose elements
      comprise (in order) the replaced arguments.
      Finally the target is called.
      What the target eventually returns is returned unchanged by the adapter.
      </p><p>
      (The array may also be a shared constant when <code>arrayLength</code> is zero.)
      </p><p>
      (<em>Note:</em> The <code>arrayType</code> is often identical to the last
      parameter type of the original target.
      It is an explicit argument for symmetry with <code>asSpreader</code>, and also
      to allow the target to use a simple <code>Object</code> as its last parameter type.)
      </p><p>
      In order to create a collecting adapter which is not restricted to a particular
      number of collected arguments, use {@link #asVarargsCollector asVarargsCollector} instead.
      </p><p>
      Here are some examples of array-collecting method handles:
      </p><blockquote><pre>{@code
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
assertEquals("[won]",   (String) deepToString.invokeExact(new Object[]{"won"}));
MethodHandle ts1 = deepToString.asCollector(Object[].class, 1);
assertEquals(methodType(String.class, Object.class), ts1.type());
//assertEquals("[won]", (String) ts1.invokeExact(         new Object[]{"won"})); //FAIL
assertEquals("[[won]]", (String) ts1.invokeExact((Object) new Object[]{"won"}));
// arrayType can be a subtype of Object[]
MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals(methodType(String.class, String.class, String.class), ts2.type());
assertEquals("[two, too]", (String) ts2.invokeExact("two", "too"));
MethodHandle ts0 = deepToString.asCollector(Object[].class, 0);
assertEquals("[]", (String) ts0.invokeExact());
// collectors can be nested, Lisp-style
MethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);
assertEquals("[A, B, [C, D]]", ((String) ts22.invokeExact((Object)'A', (Object)"B", "C", "D")));
// arrayType can be any primitive array type
MethodHandle bytesToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, byte[].class))
  .asCollector(byte[].class, 3);
assertEquals("[1, 2, 3]", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));
MethodHandle longsToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, long[].class))
  .asCollector(long[].class, 1);
assertEquals("[123]", (String) longsToString.invokeExact((long)123));
      }</pre></blockquote>
      @param arrayType often <code>Object[]</code>, the type of the array argument which will collect the arguments
      @param arrayLength the number of arguments to collect into a new array argument
      @return a new method handle which collects some trailing argument
              into an array, before calling the original method handle
      @throws NullPointerException if <code>arrayType</code> is a null reference
      @throws IllegalArgumentException if <code>arrayType</code> is not an array type
              or <code>arrayType</code> is not assignable to this method handle's trailing parameter type,
              or <code>arrayLength</code> is not a legal array size,
              or the resulting method handle's type would have
              <a href="MethodHandle.html#maxarity">too many parameters</a>
      @throws WrongMethodTypeException if the implied <code>asType</code> call fails
      @see #asSpreader
      @see #asVarargsCollector</div>
<a id="L994" name="L994"></a> 994     <strong class="reserved">public</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/10334.html" title="Multiple referred from 5 places.">asCollector</a>(<a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType, <strong class="reserved">int</strong> <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>) <em class="brace">{</em>
<a id="L995" name="L995"></a> 995         <a href="../S/1623.html#L1012" title="Defined at 1012 in src/java/lang/invoke/MethodHandle.java.">asCollectorChecks</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L996" name="L996"></a> 996         <strong class="reserved">int</strong> collectArgPos = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/29054.html" title="Multiple defined in 2 places.">parameterCount</a>() - 1;
<a id="L997" name="L997"></a> 997         <a href="../S/1606.html#L53" title="Defined at 53 in src/java/lang/invoke/BoundMethodHandle.java.">BoundMethodHandle</a> mh = <a href="../D/30364.html" title="Multiple defined in 23 places.">rebind</a>();
<a id="L998" name="L998"></a> 998         <a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> <a href="../S/6110.html#L162" title="Defined at 162 in src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodType.java.">resultType</a> = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../S/1616.html#L517" title="Defined at 517 in src/java/lang/invoke/MethodType.java.">asCollectorType</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L999" name="L999"></a> 999         <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../D/27956.html" title="Multiple defined in 13 places.">newArray</a> = <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../D/36386.html" title="Multiple defined in 2 places.">varargsArray</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L1000" name="L1000"></a>1000         <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> lform = mh.<a href="../D/15284.html" title="Multiple defined in 2 places.">editor</a>().<a href="../S/1629.html#L583" title="Defined at 583 in src/java/lang/invoke/LambdaFormEditor.java.">collectArgumentArrayForm</a>(1 + collectArgPos, <a href="../D/27956.html" title="Multiple defined in 13 places.">newArray</a>);
<a id="L1001" name="L1001"></a>1001         <strong class="reserved">if</strong> (lform != <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L1002" name="L1002"></a>1002             <strong class="reserved">return</strong> mh.<a href="../D/13534.html" title="Multiple defined in 10 places.">copyWith</a>(<a href="../S/6110.html#L162" title="Defined at 162 in src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodType.java.">resultType</a>, lform);
<a id="L1003" name="L1003"></a>1003         <em class="brace">}</em>
<a id="L1004" name="L1004"></a>1004         lform = mh.<a href="../D/15284.html" title="Multiple defined in 2 places.">editor</a>().<a href="../S/1629.html#L562" title="Defined at 562 in src/java/lang/invoke/LambdaFormEditor.java.">collectArgumentsForm</a>(1 + collectArgPos, <a href="../D/27956.html" title="Multiple defined in 13 places.">newArray</a>.<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/11785.html" title="Multiple defined in 6 places.">basicType</a>());
<a id="L1005" name="L1005"></a>1005         <strong class="reserved">return</strong> mh.<a href="../D/13539.html" title="Multiple defined in 3 places.">copyWithExtendL</a>(<a href="../S/6110.html#L162" title="Defined at 162 in src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/MethodType.java.">resultType</a>, lform, <a href="../D/27956.html" title="Multiple defined in 13 places.">newArray</a>);
<a id="L1006" name="L1006"></a>1006     <em class="brace">}</em>
<a id="L1007" name="L1007"></a>1007 
<div class="comment">
      See if <code>asCollector</code> can be validly called with the given arguments.
      Return false if the last parameter is not an exact match to arrayType.</div>
<div class="comment">
     /*non-public*/</div> <strong class="reserved">boolean</strong> <a href="../R/10335.html" title="Multiple referred from 2 places.">asCollectorChecks</a>(<a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType, <strong class="reserved">int</strong> <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>) <em class="brace">{</em>
<a id="L1013" name="L1013"></a>1013         <a href="../S/1623.html#L909" title="Defined at 909 in src/java/lang/invoke/MethodHandle.java.">spreadArrayChecks</a>(arrayType, <a href="../D/11507.html" title="Multiple defined in 4 places.">arrayLength</a>);
<a id="L1014" name="L1014"></a>1014         <strong class="reserved">int</strong> nargs = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/29054.html" title="Multiple defined in 2 places.">parameterCount</a>();
<a id="L1015" name="L1015"></a>1015         <strong class="reserved">if</strong> (nargs != 0) <em class="brace">{</em>
<a id="L1016" name="L1016"></a>1016             <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; lastParam = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/29061.html" title="Multiple defined in 3 places.">parameterType</a>(nargs-1);
<a id="L1017" name="L1017"></a>1017             <strong class="reserved">if</strong> (lastParam == arrayType)  <strong class="reserved">return</strong> <strong class="reserved">true</strong>;
<a id="L1018" name="L1018"></a>1018             <strong class="reserved">if</strong> (lastParam.<a href="../D/25213.html" title="Multiple defined in 7 places.">isAssignableFrom</a>(arrayType))  <strong class="reserved">return</strong> <strong class="reserved">false</strong>;
<a id="L1019" name="L1019"></a>1019         <em class="brace">}</em>
<a id="L1020" name="L1020"></a>1020         <strong class="reserved">throw</strong> <a href="../D/28010.html" title="Multiple defined in 3 places.">newIllegalArgumentException</a>("array type not assignable to trailing argument", <strong class="reserved">this</strong>, arrayType);
<a id="L1021" name="L1021"></a>1021     <em class="brace">}</em>
<a id="L1022" name="L1022"></a>1022 
<div class="comment">
      Makes a <em>variable arity</em> adapter which is able to accept
      any number of trailing positional arguments and collect them
      into an array argument.
      <p>
      The type and behavior of the adapter will be the same as
      the type and behavior of the target, except that certain
      <code>invoke</code> and <code>asType</code> requests can lead to
      trailing positional arguments being collected into target's
      trailing parameter.
      Also, the last parameter type of the adapter will be
      <code>arrayType</code>, even if the target has a different
      last parameter type.
      </p><p>
      This transformation may return <code>this</code> if the method handle is
      already of variable arity and its trailing parameter type
      is identical to <code>arrayType</code>.
      </p><p>
      When called with {@link #invokeExact invokeExact}, the adapter invokes
      the target with no argument changes.
      (<em>Note:</em> This behavior is different from a
      {@linkplain #asCollector fixed arity collector},
      since it accepts a whole array of indeterminate length,
      rather than a fixed number of arguments.)
      </p><p>
      When called with plain, inexact {@link #invoke invoke}, if the caller
      type is the same as the adapter, the adapter invokes the target as with
      <code>invokeExact</code>.
      (This is the normal behavior for <code>invoke</code> when types match.)
      </p><p>
      Otherwise, if the caller and adapter arity are the same, and the
      trailing parameter type of the caller is a reference type identical to
      or assignable to the trailing parameter type of the adapter,
      the arguments and return values are converted pairwise,
      as if by {@link #asType asType} on a fixed arity
      method handle.
      </p><p>
      Otherwise, the arities differ, or the adapter's trailing parameter
      type is not assignable from the corresponding caller type.
      In this case, the adapter replaces all trailing arguments from
      the original trailing argument position onward, by
      a new array of type <code>arrayType</code>, whose elements
      comprise (in order) the replaced arguments.
      </p><p>
      The caller type must provides as least enough arguments,
      and of the correct type, to satisfy the target's requirement for
      positional arguments before the trailing array argument.
      Thus, the caller must supply, at a minimum, <code>N-1</code> arguments,
      where <code>N</code> is the arity of the target.
      Also, there must exist conversions from the incoming arguments
      to the target's arguments.
      As with other uses of plain <code>invoke</code>, if these basic
      requirements are not fulfilled, a <code>WrongMethodTypeException</code>
      may be thrown.
      </p><p>
      In all cases, what the target eventually returns is returned unchanged by the adapter.
      </p><p>
      In the final case, it is exactly as if the target method handle were
      temporarily adapted with a {@linkplain #asCollector fixed arity collector}
      to the arity required by the caller type.
      (As with <code>asCollector</code>, if the array length is zero,
      a shared constant may be used instead of a new array.
      If the implied call to <code>asCollector</code> would throw
      an <code>IllegalArgumentException</code> or <code>WrongMethodTypeException</code>,
      the call to the variable arity adapter must throw
      <code>WrongMethodTypeException</code>.)
      </p><p>
      The behavior of {@link #asType asType} is also specialized for
      variable arity adapters, to maintain the invariant that
      plain, inexact <code>invoke</code> is always equivalent to an <code>asType</code>
      call to adjust the target type, followed by <code>invokeExact</code>.
      Therefore, a variable arity adapter responds
      to an <code>asType</code> request by building a fixed arity collector,
      if and only if the adapter and requested type differ either
      in arity or trailing argument type.
      The resulting fixed arity collector has its type further adjusted
      (if necessary) to the requested type by pairwise conversion,
      as if by another application of <code>asType</code>.
      </p><p>
      When a method handle is obtained by executing an <code>ldc</code> instruction
      of a <code>CONSTANT_MethodHandle</code> constant, and the target method is marked
      as a variable arity method (with the modifier bit <code>0x0080</code>),
      the method handle will accept multiple arities, as if the method handle
      constant were created by means of a call to <code>asVarargsCollector</code>.
      </p><p>
      In order to create a collecting adapter which collects a predetermined
      number of arguments, and whose type reflects this predetermined number,
      use {@link #asCollector asCollector} instead.
      </p><p>
      No method handle transformations produce new method handles with
      variable arity, unless they are documented as doing so.
      Therefore, besides <code>asVarargsCollector</code>,
      all methods in <code>MethodHandle</code> and <code>MethodHandles</code>
      will return a method handle with fixed arity,
      except in the cases where they are specified to return their original
      operand (e.g., <code>asType</code> of the method handle's own type).
      </p><p>
      Calling <code>asVarargsCollector</code> on a method handle which is already
      of variable arity will produce a method handle with the same type and behavior.
      It may (or may not) return the original variable arity method handle.
      </p><p>
      Here is an example, of a list-making variable arity method handle:
      </p><blockquote><pre>{@code
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
MethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);
assertEquals("[won]",   (String) ts1.invokeExact(    new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(         new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(                      "won" ));
assertEquals("[[won]]", (String) ts1.invoke((Object) new Object[]{"won"}));
// findStatic of Arrays.asList(...) produces a variable arity method handle:
MethodHandle asList = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));
assertEquals(methodType(List.class, Object[].class), asList.type());
assert(asList.isVarargsCollector());
assertEquals("[]", asList.invoke().toString());
assertEquals("[1]", asList.invoke(1).toString());
assertEquals("[two, too]", asList.invoke("two", "too").toString());
String[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asList.invoke(argv).toString());
assertEquals("[three, thee, tee]", asList.invoke((Object[])argv).toString());
List ls = (List) asList.invoke((Object)argv);
assertEquals(1, ls.size());
assertEquals("[three, thee, tee]", Arrays.toString((Object[])ls.get(0)));
      }</pre></blockquote>
      <p style="font-size:smaller;">
      <em>Discussion:</em>
      These rules are designed as a dynamically-typed variation
      of the Java rules for variable arity methods.
      In both cases, callers to a variable arity method or method handle
      can either pass zero or more positional arguments, or else pass
      pre-collected arrays of any length.  Users should be aware of the
      special role of the final argument, and of the effect of a
      type match on that final argument, which determines whether
      or not a single trailing argument is interpreted as a whole
      array or a single element of an array to be collected.
      Note that the dynamic type of the trailing argument has no
      effect on this decision, only a comparison between the symbolic
      type descriptor of the call site and the type descriptor of the method handle.)
      @param arrayType often <code>Object[]</code>, the type of the array argument which will collect the arguments
      @return a new method handle which can collect any number of trailing arguments
              into an array, before calling the original method handle
      @throws NullPointerException if <code>arrayType</code> is a null reference
      @throws IllegalArgumentException if <code>arrayType</code> is not an array type
              or <code>arrayType</code> is not assignable to this method handle's trailing parameter type
      @see #asCollector
      @see #isVarargsCollector
      @see #asFixedArity</p></div>
<a id="L1173" name="L1173"></a>1173     <strong class="reserved">public</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/10360.html" title="Multiple referred from 2 places.">asVarargsCollector</a>(<a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType) <em class="brace">{</em>
<a id="L1174" name="L1174"></a>1174         arrayType.<a href="../D/17675.html" title="Multiple defined in 6 places.">getClass</a>(); <em class="comment">// explicit NPE</em>
<a id="L1175" name="L1175"></a>1175         <strong class="reserved">boolean</strong> lastMatch = <a href="../S/1623.html#L1012" title="Defined at 1012 in src/java/lang/invoke/MethodHandle.java.">asCollectorChecks</a>(arrayType, 0);
<a id="L1176" name="L1176"></a>1176         <strong class="reserved">if</strong> (<a href="../D/26478.html" title="Multiple defined in 2 places.">isVarargsCollector</a>() &amp;&amp; lastMatch)
<a id="L1177" name="L1177"></a>1177             <strong class="reserved">return</strong> <strong class="reserved">this</strong>;
<a id="L1178" name="L1178"></a>1178         <strong class="reserved">return</strong> <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../S/1634.html#L439" title="Defined at 439 in src/java/lang/invoke/MethodHandleImpl.java.">makeVarargsCollector</a>(<strong class="reserved">this</strong>, arrayType);
<a id="L1179" name="L1179"></a>1179     <em class="brace">}</em>
<a id="L1180" name="L1180"></a>1180 
<div class="comment">
      Determines if this method handle
      supports {@linkplain #asVarargsCollector variable arity} calls.
      Such method handles arise from the following sources:
      <ul><li>a call to {@linkplain #asVarargsCollector asVarargsCollector}
      </li><li>a call to a {@linkplain java.lang.invoke.MethodHandles.Lookup lookup method}
          which resolves to a variable arity Java method or constructor
      </li><li>an <code>ldc</code> instruction of a <code>CONSTANT_MethodHandle</code>
          which resolves to a variable arity Java method or constructor
      </li></ul>
      @return true if this method handle accepts more than one arity of plain, inexact <code>invoke</code> calls
      @see #asVarargsCollector
      @see #asFixedArity</div>
<a id="L1196" name="L1196"></a>1196     <strong class="reserved">public</strong> <strong class="reserved">boolean</strong> <a href="../R/22211.html" title="Multiple referred from 5 places.">isVarargsCollector</a>() <em class="brace">{</em>
<a id="L1197" name="L1197"></a>1197         <strong class="reserved">return</strong> <strong class="reserved">false</strong>;
<a id="L1198" name="L1198"></a>1198     <em class="brace">}</em>
<a id="L1199" name="L1199"></a>1199 
<div class="comment">
      Makes a <em>fixed arity</em> method handle which is otherwise
      equivalent to the current method handle.
      <p>
      If the current method handle is not of
      {@linkplain #asVarargsCollector variable arity},
      the current method handle is returned.
      This is true even if the current method handle
      could not be a valid input to <code>asVarargsCollector</code>.
      </p><p>
      Otherwise, the resulting fixed-arity method handle has the same
      type and behavior of the current method handle,
      except that {@link #isVarargsCollector isVarargsCollector}
      will be false.
      The fixed-arity method handle may (or may not) be the
      a previous argument to <code>asVarargsCollector</code>.
      </p><p>
      Here is an example, of a list-making variable arity method handle:
      </p><blockquote><pre>{@code
MethodHandle asListVar = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class))
  .asVarargsCollector(Object[].class);
MethodHandle asListFix = asListVar.asFixedArity();
assertEquals("[1]", asListVar.invoke(1).toString());
Exception caught = null;
try { asListFix.invoke((Object)1); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof ClassCastException);
assertEquals("[two, too]", asListVar.invoke("two", "too").toString());
try { asListFix.invoke("two", "too"); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof WrongMethodTypeException);
Object[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asListVar.invoke(argv).toString());
assertEquals("[three, thee, tee]", asListFix.invoke(argv).toString());
assertEquals(1, ((List) asListVar.invoke((Object)argv)).size());
assertEquals("[three, thee, tee]", asListFix.invoke((Object)argv).toString());
      }</pre></blockquote>
      @return a new method handle which accepts only a fixed number of arguments
      @see #asVarargsCollector
      @see #isVarargsCollector</div>
<a id="L1243" name="L1243"></a>1243     <strong class="reserved">public</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/10341.html" title="Multiple referred from 8 places.">asFixedArity</a>() <em class="brace">{</em>
<a id="L1244" name="L1244"></a>1244         <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(!<a href="../D/26478.html" title="Multiple defined in 2 places.">isVarargsCollector</a>());
<a id="L1245" name="L1245"></a>1245         <strong class="reserved">return</strong> <strong class="reserved">this</strong>;
<a id="L1246" name="L1246"></a>1246     <em class="brace">}</em>
<a id="L1247" name="L1247"></a>1247 
<div class="comment">
      Binds a value <code>x</code> to the first argument of a method handle, without invoking it.
      The new method handle adapts, as its <i>target</i>,
      the current method handle by binding it to the given argument.
      The type of the bound handle will be
      the same as the type of the target, except that a single leading
      reference parameter will be omitted.
      <p>
      When called, the bound handle inserts the given value <code>x</code>
      as a new leading argument to the target.  The other arguments are
      also passed unchanged.
      What the target eventually returns is returned unchanged by the bound handle.
      </p><p>
      The reference <code>x</code> must be convertible to the first parameter
      type of the target.
      </p><p>
      (<em>Note:</em>  Because method handles are immutable, the target method handle
      retains its original type and behavior.)
      @param x  the value to bind to the first argument of the target
      @return a new method handle which prepends the given value to the incoming
              argument list, before calling the original method handle
      @throws IllegalArgumentException if the target does not have a
              leading parameter type that is a reference type
      @throws ClassCastException if <code>x</code> cannot be converted
              to the leading parameter type of the target
      @see MethodHandles#insertArguments</p></div>
<a id="L1275" name="L1275"></a>1275     <strong class="reserved">public</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/10610.html" title="Multiple referred from 9 places.">bindTo</a>(<a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../D/37285.html" title="Multiple defined in 2 places.">x</a>) <em class="brace">{</em>
<a id="L1276" name="L1276"></a>1276         <a href="../D/37285.html" title="Multiple defined in 2 places.">x</a> = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>.<a href="../S/1616.html#L504" title="Defined at 504 in src/java/lang/invoke/MethodType.java.">leadingReferenceParameter</a>().<a href="../D/12274.html" title="Multiple defined in 6 places.">cast</a>(<a href="../D/37285.html" title="Multiple defined in 2 places.">x</a>);  <em class="comment">// throw CCE if needed</em>
<a id="L1277" name="L1277"></a>1277         <strong class="reserved">return</strong> <a href="../D/11851.html" title="Multiple defined in 3 places.">bindArgumentL</a>(0, <a href="../D/37285.html" title="Multiple defined in 2 places.">x</a>);
<a id="L1278" name="L1278"></a>1278     <em class="brace">}</em>
<a id="L1279" name="L1279"></a>1279 
<div class="comment">
      Returns a string representation of the method handle,
      starting with the string <code>"MethodHandle"</code> and
      ending with the string representation of the method handle's type.
      In other words, this method returns a string equal to the value of:
      <blockquote><pre>{@code
      "MethodHandle" + type().toString()
      }</pre></blockquote>
      <p>
      (<em>Note:</em>  Future releases of this API may add further information
      to the string representation.
      Therefore, the present syntax should not be parsed by applications.)
      @return a string representation of the method handle</p></div>
<a id="L1295" name="L1295"></a>1295     @<a href="../S/1740.html#L51" title="Defined at 51 in src/java/lang/Override.java.">Override</a>
<a id="L1296" name="L1296"></a>1296     <strong class="reserved">public</strong> <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../R/29337.html" title="Multiple referred from 3013 places.">toString</a>() <em class="brace">{</em>
<a id="L1297" name="L1297"></a>1297         <strong class="reserved">if</strong> (DEBUG_METHOD_HANDLE_NAMES)  <strong class="reserved">return</strong> "MethodHandle"+<a href="../D/14498.html" title="Multiple defined in 3 places.">debugString</a>();
<a id="L1298" name="L1298"></a>1298         <strong class="reserved">return</strong> <a href="../S/1623.html#L1300" title="Defined at 1300 in src/java/lang/invoke/MethodHandle.java.">standardString</a>();
<a id="L1299" name="L1299"></a>1299     <em class="brace">}</em>
<a id="L1300" name="L1300"></a>1300     <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../S/1623.html#L1298" title="Referred from 1298 in src/java/lang/invoke/MethodHandle.java.">standardString</a>() <em class="brace">{</em>
<a id="L1301" name="L1301"></a>1301         <strong class="reserved">return</strong> "MethodHandle"+<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>;
<a id="L1302" name="L1302"></a>1302     <em class="brace">}</em>
<div class="comment">
 Return a string with a several lines describing the method handle structure.
       This string would be suitable for display in an IDE debugger.</div>
<a id="L1306" name="L1306"></a>1306     <a href="../D/8419.html" title="Multiple defined in 2 places.">String</a> <a href="../R/12926.html" title="Multiple referred from 17 places.">debugString</a>() <em class="brace">{</em>
<a id="L1307" name="L1307"></a>1307         <strong class="reserved">return</strong> <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>+" : "+<a href="../S/1623.html#L1357" title="Defined at 1357 in src/java/lang/invoke/MethodHandle.java.">internalForm</a>()+<a href="../D/24948.html" title="Multiple defined in 6 places.">internalProperties</a>();
<a id="L1308" name="L1308"></a>1308     <em class="brace">}</em>
<a id="L1309" name="L1309"></a>1309 
<a id="L1310" name="L1310"></a>1310     <em class="comment">//// Implementation methods.</em>
<a id="L1311" name="L1311"></a>1311     <em class="comment">//// Sub-classes can override these default implementations.</em>
<a id="L1312" name="L1312"></a>1312     <em class="comment">//// All these methods assume arguments are already validated.</em>
<a id="L1313" name="L1313"></a>1313 
<a id="L1314" name="L1314"></a>1314     <em class="comment">// Other transforms to do:  convert, explicitCast, permute, drop, filter, fold, GWT, catch</em>
<a id="L1315" name="L1315"></a>1315 
<a id="L1316" name="L1316"></a>1316     <a href="../S/1606.html#L53" title="Defined at 53 in src/java/lang/invoke/BoundMethodHandle.java.">BoundMethodHandle</a> <a href="../R/10605.html" title="Multiple referred from 6 places.">bindArgumentL</a>(<strong class="reserved">int</strong> pos, <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../D/36360.html" title="Multiple defined in 73 places.">value</a>) <em class="brace">{</em>
<a id="L1317" name="L1317"></a>1317         <strong class="reserved">return</strong> <a href="../D/30364.html" title="Multiple defined in 23 places.">rebind</a>().<a href="../D/11851.html" title="Multiple defined in 3 places.">bindArgumentL</a>(pos, <a href="../D/36360.html" title="Multiple defined in 73 places.">value</a>);
<a id="L1318" name="L1318"></a>1318     <em class="brace">}</em>
<a id="L1319" name="L1319"></a>1319 
<div class="comment">
     /*non-public*/</div>
<a id="L1321" name="L1321"></a>1321     <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/28381.html" title="Multiple referred from 3 places.">setVarargs</a>(<a href="../S/1611.html#L72" title="Defined at 72 in src/java/lang/invoke/MemberName.java.">MemberName</a> <a href="../D/27605.html" title="Multiple defined in 5 places.">member</a>) <strong class="reserved">throws</strong> <a href="../S/1574.html#L59" title="Defined at 59 in src/java/lang/IllegalAccessException.java.">IllegalAccessException</a> <em class="brace">{</em>
<a id="L1322" name="L1322"></a>1322         <strong class="reserved">if</strong> (!<a href="../D/27605.html" title="Multiple defined in 5 places.">member</a>.<a href="../S/1611.html#L416" title="Defined at 416 in src/java/lang/invoke/MemberName.java.">isVarargs</a>())  <strong class="reserved">return</strong> <strong class="reserved">this</strong>;
<a id="L1323" name="L1323"></a>1323         <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; arrayType = <a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../S/1616.html#L732" title="Defined at 732 in src/java/lang/invoke/MethodType.java.">lastParameterType</a>();
<a id="L1324" name="L1324"></a>1324         <strong class="reserved">if</strong> (arrayType.<a href="../D/25208.html" title="Multiple defined in 5 places.">isArray</a>()) <em class="brace">{</em>
<a id="L1325" name="L1325"></a>1325             <strong class="reserved">return</strong> <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../S/1634.html#L439" title="Defined at 439 in src/java/lang/invoke/MethodHandleImpl.java.">makeVarargsCollector</a>(<strong class="reserved">this</strong>, arrayType);
<a id="L1326" name="L1326"></a>1326         <em class="brace">}</em>
<a id="L1327" name="L1327"></a>1327         <strong class="reserved">throw</strong> <a href="../D/27605.html" title="Multiple defined in 5 places.">member</a>.<a href="../D/27201.html" title="Multiple defined in 2 places.">makeAccessException</a>("cannot make variable arity", <strong class="reserved">null</strong>);
<a id="L1328" name="L1328"></a>1328     <em class="brace">}</em>
<a id="L1329" name="L1329"></a>1329 
<div class="comment">
     /*non-public*/</div>
<a id="L1331" name="L1331"></a>1331     <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/30134.html" title="Multiple referred from 3 places.">viewAsType</a>(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> newType, <strong class="reserved">boolean</strong> strict) <em class="brace">{</em>
<a id="L1332" name="L1332"></a>1332         <em class="comment">// No actual conversions, just a new view of the same method.</em>
<a id="L1333" name="L1333"></a>1333         <em class="comment">// Note that this operation must not produce a DirectMethodHandle,</em>
<a id="L1334" name="L1334"></a>1334         <em class="comment">// because retyped DMHs, like any transformed MHs,</em>
<a id="L1335" name="L1335"></a>1335         <em class="comment">// cannot be cracked into MethodHandleInfo.</em>
<a id="L1336" name="L1336"></a>1336         <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a> <a href="../D/36413.html" title="Multiple defined in 2 places.">viewAsTypeChecks</a>(newType, strict);
<a id="L1337" name="L1337"></a>1337         <a href="../S/1606.html#L53" title="Defined at 53 in src/java/lang/invoke/BoundMethodHandle.java.">BoundMethodHandle</a> mh = <a href="../D/30364.html" title="Multiple defined in 23 places.">rebind</a>();
<a id="L1338" name="L1338"></a>1338         <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(!((<a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a>)mh <strong class="reserved">instanceof</strong> <a href="../S/1620.html#L47" title="Defined at 47 in src/java/lang/invoke/DirectMethodHandle.java.">DirectMethodHandle</a>));
<a id="L1339" name="L1339"></a>1339         <strong class="reserved">return</strong> mh.<a href="../D/13534.html" title="Multiple defined in 10 places.">copyWith</a>(newType, mh.<a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>);
<a id="L1340" name="L1340"></a>1340     <em class="brace">}</em>
<a id="L1341" name="L1341"></a>1341 
<div class="comment">
     /*non-public*/</div>
<a id="L1343" name="L1343"></a>1343     <strong class="reserved">boolean</strong> <a href="../R/30135.html" title="Multiple referred from 3 places.">viewAsTypeChecks</a>(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> newType, <strong class="reserved">boolean</strong> strict) <em class="brace">{</em>
<a id="L1344" name="L1344"></a>1344         <strong class="reserved">if</strong> (strict) <em class="brace">{</em>
<a id="L1345" name="L1345"></a>1345             <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../S/1616.html#L808" title="Defined at 808 in src/java/lang/invoke/MethodType.java.">isViewableAs</a>(newType, <strong class="reserved">true</strong>))
<a id="L1346" name="L1346"></a>1346                 : <a href="../S/1150.html#L71" title="Defined at 71 in src/java/util/Arrays.java.">Arrays</a>.<a href="../D/11544.html" title="Multiple defined in 4 places.">asList</a>(<strong class="reserved">this</strong>, newType);
<a id="L1347" name="L1347"></a>1347         <em class="brace">}</em> <strong class="reserved">else</strong> <em class="brace">{</em>
<a id="L1348" name="L1348"></a>1348             <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(<a href="../D/35749.html" title="Multiple defined in 239 places.">type</a>().<a href="../D/11785.html" title="Multiple defined in 6 places.">basicType</a>().<a href="../S/1616.html#L808" title="Defined at 808 in src/java/lang/invoke/MethodType.java.">isViewableAs</a>(newType.<a href="../D/11785.html" title="Multiple defined in 6 places.">basicType</a>(), <strong class="reserved">true</strong>))
<a id="L1349" name="L1349"></a>1349                 : <a href="../S/1150.html#L71" title="Defined at 71 in src/java/util/Arrays.java.">Arrays</a>.<a href="../D/11544.html" title="Multiple defined in 4 places.">asList</a>(<strong class="reserved">this</strong>, newType);
<a id="L1350" name="L1350"></a>1350         <em class="brace">}</em>
<a id="L1351" name="L1351"></a>1351         <strong class="reserved">return</strong> <strong class="reserved">true</strong>;
<a id="L1352" name="L1352"></a>1352     <em class="brace">}</em>
<a id="L1353" name="L1353"></a>1353 
<a id="L1354" name="L1354"></a>1354     <em class="comment">// Decoding</em>
<a id="L1355" name="L1355"></a>1355 
<div class="comment">
     /*non-public*/</div>
<a id="L1357" name="L1357"></a>1357     <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> <a href="../R/20931.html" title="Multiple referred from 6 places.">internalForm</a>() <em class="brace">{</em>
<a id="L1358" name="L1358"></a>1358         <strong class="reserved">return</strong> <a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>;
<a id="L1359" name="L1359"></a>1359     <em class="brace">}</em>
<a id="L1360" name="L1360"></a>1360 
<div class="comment">
     /*non-public*/</div>
<a id="L1362" name="L1362"></a>1362     <a href="../S/1611.html#L72" title="Defined at 72 in src/java/lang/invoke/MemberName.java.">MemberName</a> <a href="../R/20950.html" title="Multiple referred from 20 places.">internalMemberName</a>() <em class="brace">{</em>
<a id="L1363" name="L1363"></a>1363         <strong class="reserved">return</strong> <strong class="reserved">null</strong>;  <em class="comment">// DMH returns DMH.member</em>
<a id="L1364" name="L1364"></a>1364     <em class="brace">}</em>
<a id="L1365" name="L1365"></a>1365 
<div class="comment">
     /*non-public*/</div>
<a id="L1367" name="L1367"></a>1367     <a href="../S/1722.html#L119" title="Defined at 119 in src/java/lang/Class.java.">Class</a>&lt;?&gt; <a href="../R/20923.html" title="Multiple referred from 2 places.">internalCallerClass</a>() <em class="brace">{</em>
<a id="L1368" name="L1368"></a>1368         <strong class="reserved">return</strong> <strong class="reserved">null</strong>;  <em class="comment">// caller-bound MH for @CallerSensitive method returns caller</em>
<a id="L1369" name="L1369"></a>1369     <em class="brace">}</em>
<a id="L1370" name="L1370"></a>1370 
<div class="comment">
     /*non-public*/</div>
<a id="L1372" name="L1372"></a>1372     <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../S/1634.html#L1313" title="Defined at 1313 in src/java/lang/invoke/MethodHandleImpl.java.">Intrinsic</a> <a href="../R/20992.html" title="Multiple referred from 15 places.">intrinsicName</a>() <em class="brace">{</em>
<a id="L1373" name="L1373"></a>1373         <em class="comment">// no special intrinsic meaning to most MHs</em>
<a id="L1374" name="L1374"></a>1374         <strong class="reserved">return</strong> <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../S/1634.html#L1313" title="Defined at 1313 in src/java/lang/invoke/MethodHandleImpl.java.">Intrinsic</a>.<a href="../D/5884.html" title="Multiple defined in 2 places.">NONE</a>;
<a id="L1375" name="L1375"></a>1375     <em class="brace">}</em>
<a id="L1376" name="L1376"></a>1376 
<div class="comment">
     /*non-public*/</div>
<a id="L1378" name="L1378"></a>1378     <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/30506.html" title="Multiple referred from 2 places.">withInternalMemberName</a>(<a href="../S/1611.html#L72" title="Defined at 72 in src/java/lang/invoke/MemberName.java.">MemberName</a> <a href="../D/27605.html" title="Multiple defined in 5 places.">member</a>, <strong class="reserved">boolean</strong> <a href="../D/25745.html" title="Multiple defined in 4 places.">isInvokeSpecial</a>) <em class="brace">{</em>
<a id="L1379" name="L1379"></a>1379         <strong class="reserved">if</strong> (<a href="../D/27605.html" title="Multiple defined in 5 places.">member</a> != <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L1380" name="L1380"></a>1380             <strong class="reserved">return</strong> <a href="../S/1634.html#L49" title="Defined at 49 in src/java/lang/invoke/MethodHandleImpl.java.">MethodHandleImpl</a>.<a href="../S/1634.html#L1305" title="Defined at 1305 in src/java/lang/invoke/MethodHandleImpl.java.">makeWrappedMember</a>(<strong class="reserved">this</strong>, <a href="../D/27605.html" title="Multiple defined in 5 places.">member</a>, <a href="../D/25745.html" title="Multiple defined in 4 places.">isInvokeSpecial</a>);
<a id="L1381" name="L1381"></a>1381         <em class="brace">}</em> <strong class="reserved">else</strong> <strong class="reserved">if</strong> (<a href="../D/24941.html" title="Multiple defined in 5 places.">internalMemberName</a>() == <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L1382" name="L1382"></a>1382             <em class="comment">// The required internaMemberName is null, and this MH (like most) doesn't have one.</em>
<a id="L1383" name="L1383"></a>1383             <strong class="reserved">return</strong> <strong class="reserved">this</strong>;
<a id="L1384" name="L1384"></a>1384         <em class="brace">}</em> <strong class="reserved">else</strong> <em class="brace">{</em>
<a id="L1385" name="L1385"></a>1385             <em class="comment">// The following case is rare. Mask the internalMemberName by wrapping the MH in a BMH.</em>
<a id="L1386" name="L1386"></a>1386             <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../D/31365.html" title="Multiple defined in 7 places.">result</a> = <a href="../D/30364.html" title="Multiple defined in 23 places.">rebind</a>();
<a id="L1387" name="L1387"></a>1387             <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a> (<a href="../D/31365.html" title="Multiple defined in 7 places.">result</a>.<a href="../D/24941.html" title="Multiple defined in 5 places.">internalMemberName</a>() == <strong class="reserved">null</strong>);
<a id="L1388" name="L1388"></a>1388             <strong class="reserved">return</strong> <a href="../D/31365.html" title="Multiple defined in 7 places.">result</a>;
<a id="L1389" name="L1389"></a>1389         <em class="brace">}</em>
<a id="L1390" name="L1390"></a>1390     <em class="brace">}</em>
<a id="L1391" name="L1391"></a>1391 
<div class="comment">
     /*non-public*/</div>
<a id="L1393" name="L1393"></a>1393     <strong class="reserved">boolean</strong> <a href="../R/21612.html" title="Multiple referred from 12 places.">isInvokeSpecial</a>() <em class="brace">{</em>
<a id="L1394" name="L1394"></a>1394         <strong class="reserved">return</strong> <strong class="reserved">false</strong>;  <em class="comment">// DMH.Special returns true</em>
<a id="L1395" name="L1395"></a>1395     <em class="brace">}</em>
<a id="L1396" name="L1396"></a>1396 
<div class="comment">
     /*non-public*/</div>
<a id="L1398" name="L1398"></a>1398     <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../S/1606.html#L163" title="Referred from 163 in src/java/lang/invoke/BoundMethodHandle.java.">internalValues</a>() <em class="brace">{</em>
<a id="L1399" name="L1399"></a>1399         <strong class="reserved">return</strong> <strong class="reserved">null</strong>;
<a id="L1400" name="L1400"></a>1400     <em class="brace">}</em>
<a id="L1401" name="L1401"></a>1401 
<div class="comment">
     /*non-public*/</div>
<a id="L1403" name="L1403"></a>1403     <a href="../D/6272.html" title="Multiple defined in 7 places.">Object</a> <a href="../R/20955.html" title="Multiple referred from 2 places.">internalProperties</a>() <em class="brace">{</em>
<a id="L1404" name="L1404"></a>1404         <em class="comment">// Override to something to follow this.form, like "\n&amp; FOO=bar"</em>
<a id="L1405" name="L1405"></a>1405         <strong class="reserved">return</strong> "";
<a id="L1406" name="L1406"></a>1406     <em class="brace">}</em>
<a id="L1407" name="L1407"></a>1407 
<a id="L1408" name="L1408"></a>1408     <em class="comment">//// Method handle implementation methods.</em>
<a id="L1409" name="L1409"></a>1409     <em class="comment">//// Sub-classes can override these default implementations.</em>
<a id="L1410" name="L1410"></a>1410     <em class="comment">//// All these methods assume arguments are already validated.</em>
<a id="L1411" name="L1411"></a>1411 
<div class="comment">
     /*non-public*/</div>
<a id="L1413" name="L1413"></a>1413     <strong class="reserved">abstract</strong> <a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a> <a href="../R/12145.html" title="Multiple referred from 8 places.">copyWith</a>(<a href="../D/5628.html" title="Multiple defined in 4 places.">MethodType</a> mt, <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> lf);
<a id="L1414" name="L1414"></a>1414 
<div class="comment">
 Require this method handle to be a BMH, or else replace it with a "wrapper" BMH.
       Many transforms are implemented only for BMHs.
       @return a behaviorally equivalent BMH</div>
<a id="L1419" name="L1419"></a>1419     <strong class="reserved">abstract</strong> <a href="../S/1606.html#L53" title="Defined at 53 in src/java/lang/invoke/BoundMethodHandle.java.">BoundMethodHandle</a> <a href="../R/25634.html" title="Multiple referred from 46 places.">rebind</a>();
<a id="L1420" name="L1420"></a>1420 
<div class="comment">
      Replace the old lambda form of this method handle with a new one.
      The new one must be functionally equivalent to the old one.
      Threads may continue running the old form indefinitely,
      but it is likely that the new one will be preferred for new executions.
      Use with discretion.</div>
<div class="comment">
     /*non-public*/</div>
<a id="L1429" name="L1429"></a>1429     <strong class="reserved">void</strong> <a href="../R/29867.html" title="Multiple referred from 4 places.">updateForm</a>(<a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> newForm) <em class="brace">{</em>
<a id="L1430" name="L1430"></a>1430         <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(newForm.customized == <strong class="reserved">null</strong> || newForm.customized == <strong class="reserved">this</strong>);
<a id="L1431" name="L1431"></a>1431         <strong class="reserved">if</strong> (<a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a> == newForm)  <strong class="reserved">return</strong>;
<a id="L1432" name="L1432"></a>1432         newForm.<a href="../D/29556.html" title="Multiple defined in 6 places.">prepare</a>();  <em class="comment">// as in MethodHandle.&lt;init&gt;</em>
<a id="L1433" name="L1433"></a>1433         UNSAFE.putObject(<strong class="reserved">this</strong>, FORM_OFFSET, newForm);
<a id="L1434" name="L1434"></a>1434         UNSAFE.fullFence();
<a id="L1435" name="L1435"></a>1435     <em class="brace">}</em>
<a id="L1436" name="L1436"></a>1436 
<div class="comment">
     /** Craft a LambdaForm customized for this particular MethodHandle */</div>
<div class="comment">
     /*non-public*/</div>
<a id="L1439" name="L1439"></a>1439     <strong class="reserved">void</strong> <a href="../R/12885.html" title="Multiple referred from 7 places.">customize</a>() <em class="brace">{</em>
<a id="L1440" name="L1440"></a>1440         <strong class="reserved">if</strong> (<a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>.customized == <strong class="reserved">null</strong>) <em class="brace">{</em>
<a id="L1441" name="L1441"></a>1441             <a href="../S/1626.html#L119" title="Defined at 119 in src/java/lang/invoke/LambdaForm.java.">LambdaForm</a> newForm = <a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>.<a href="../D/14447.html" title="Multiple defined in 6 places.">customize</a>(<strong class="reserved">this</strong>);
<a id="L1442" name="L1442"></a>1442             <a href="../S/1623.html#L1429" title="Defined at 1429 in src/java/lang/invoke/MethodHandle.java.">updateForm</a>(newForm);
<a id="L1443" name="L1443"></a>1443         <em class="brace">}</em> <strong class="reserved">else</strong> <em class="brace">{</em>
<a id="L1444" name="L1444"></a>1444             <a href="../S/1616.html#L490" title="Defined at 490 in src/java/lang/invoke/MethodType.java.">assert</a>(<a href="../S/1616.html#L125" title="Defined at 125 in src/java/lang/invoke/MethodType.java.">form</a>.customized == <strong class="reserved">this</strong>);
<a id="L1445" name="L1445"></a>1445         <em class="brace">}</em>
<a id="L1446" name="L1446"></a>1446     <em class="brace">}</em>
<a id="L1447" name="L1447"></a>1447 
<a id="L1448" name="L1448"></a>1448     <strong class="reserved">private</strong> <strong class="reserved">static</strong> <strong class="reserved">final</strong> <strong class="reserved">long</strong> FORM_OFFSET;
<a id="L1449" name="L1449"></a>1449     <strong class="reserved">static</strong> <em class="brace">{</em>
<a id="L1450" name="L1450"></a>1450         <strong class="reserved">try</strong> <em class="brace">{</em>
<a id="L1451" name="L1451"></a>1451             FORM_OFFSET = UNSAFE.<a href="../D/28395.html" title="Multiple defined in 5 places.">objectFieldOffset</a>(<a href="../S/1623.html#L421" title="Defined at 421 in src/java/lang/invoke/MethodHandle.java.">MethodHandle</a>.<strong class="reserved">class</strong>.<a href="../S/1722.html#L2065" title="Defined at 2065 in src/java/lang/Class.java.">getDeclaredField</a>("form"));
<a id="L1452" name="L1452"></a>1452         <em class="brace">}</em> <strong class="reserved">catch</strong> (<a href="../S/1731.html#L35" title="Defined at 35 in src/java/lang/ReflectiveOperationException.java.">ReflectiveOperationException</a> <a href="../S/5015.html#L111" title="Defined at 111 in src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java.">ex</a>) <em class="brace">{</em>
<a id="L1453" name="L1453"></a>1453             <strong class="reserved">throw</strong> <a href="../D/28023.html" title="Multiple defined in 3 places.">newInternalError</a>(<a href="../S/5015.html#L111" title="Defined at 111 in src/com/sun/org/apache/xerces/internal/impl/xpath/regex/RegexParser.java.">ex</a>);
<a id="L1454" name="L1454"></a>1454         <em class="brace">}</em>
<a id="L1455" name="L1455"></a>1455     <em class="brace">}</em>
<a id="L1456" name="L1456"></a>1456 <em class="brace">}</em>
</pre>
<hr>
<div class="comment">
/* [&lt;][&gt;]<a href="#L428">[^]</a><a href="#L1439">[v]</a><a href="#TOP">[top]</a>[bottom]<a href="../mains.html">[index]</a><a href="../help.html">[help]</a> */</div>
</body></html>